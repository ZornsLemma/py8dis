#########################################################################################
#
# Plan B disassembler
# By TobyLobster
#
#########################################################################################



# Quick patch to make it work under DFS 0.9:
# Reads random numbers from OS ROM, not DFS
#
# http://bbcmicro.co.uk//jsbeeb/play.php?autoboot&disc=http://bbcmicro.co.uk//gameimg/discs/586/Disc033-PlanB.ssd&noseek&patch=@4cb3,3b83:fa;@4cb3,3b87:c0;@4cb3,4ea0:ef;@4cb3,4ea2:c0



# Alternative (lets face it, better suited) random number routine:
#
# rng_zp_low = $38
# rng_zp_high = $39
#
# seeding
#     lda #1 ; seed, can be anything except 0
#     sta rng_zp_low
#     lda #0
#     sta rng_zp_high
# ; ...
# random
#     lda rng_zp_high
#     lsr
#     lda rng_zp_low
#     ror
#     eor rng_zp_high
#     sta rng_zp_high ; high part of x ^= x << 7 done
#     ror ; A has now x >> 9 and high bit comes from low byte
#     eor rng_zp_low
#     sta rng_zp_low ; x ^= x >> 9 and the low part of x ^= x << 7 done
#     eor rng_zp_high
#     sta rng_zp_high ; x ^= x << 8 done
#     rts

from commands import *
import acorn
import config
import sys

config.set_label_references(False)
config.set_indent_loops(False)
#config.set_hex_dump(False)
#config.set_hex_dump_max_bytes(0)
config.set_show_autogenerated_labels(True)
#config.set_show_cpu_state(True)
config.set_show_char_literals(False)

memory_binary = memorymanager.memory_binary
return_index = 0
found_keys = {}
return_array = {}

def eprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

def include_terminator_fn(by):
    return True

def hook(subroutine_addr, addr):
    return stringhi(addr + 3, include_terminator_fn)

def get_u8(addr):
    return memory_binary[addr]

def my_label_maker(addr, context, suggestion):
    global return_index

    if get_u8(addr) == 0x60:
        if not addr in return_array:
            return_index += 1
            return_array[addr] = return_index

        return "return" + str(return_array[addr])

    if (context >= 0x4192) and (context < 0x4200):
        if suggestion[0] == "room_decode_rect_width":
            return "current_room_door_info"
        if suggestion[0] == "room_decode_sprite_height":
            return "current_room_door_celly"
        if suggestion[0] == "room_decode_sprite_width":
            return "current_room_door_cellx"
    if (context >= 0x4600) and (context < 0x464f):
        if suggestion[0] == "room_decode_sprite_width":
            return "temp_sprite"
        if suggestion[0] == "room_decode_rect_width":
            return "temp_door_byte"
    return suggestion

def inkey_expr(addr):
    key = get_u8(addr)
    if key in acorn.inkey_enum:
        expr(addr, acorn.inkey_enum[key])
        found_keys[key] = True
    else:
        assert("inkey not found")

def picture_sprite(addr, lab, width, height):
    label(addr, lab)
    bytes_per_line = (width + 7) // 8
    byte(addr, height * bytes_per_line, bytes_per_line)

    picture_binary(addr, height * bytes_per_line)

set_label_maker_hook(my_label_maker)
load(0x1210, "orig/planb.orig", "6502")

acorn.mos_labels()
acorn.hardware_bbc()
no_automatic_comment(0x533b)

constant(0x07, "osword_sound")

sprite_widths = [
    2,1,1,1,1,1,1,1,1,2,1,1,
    1,1,1,1,2,4,1,1,1,1,1,1,
    1,1,2,2,1,1,1,4,1,1,1,1,
    1,1,2,2,2,1,1,1,1,1,1,1,
    4,4,4,4,4,4,4,4,4,4,4,4,
    4,3,3,3,3,3,3,3,3,1,1,1,
    1,2,2,2,2,3,3,3,3,4,4,4,
    4 ]
sprite_heights = [
    1,1,1,1,1,1,1,2,2,1,1,1,
    1,2,1,1,2,2,1,1,1,1,1,1,
    1,1,1,1,1,1,1,2,1,1,1,1,
    2,1,3,3,3,1,1,4,4,4,4,4,
    1,1,1,1,1,4,4,4,4,4,4,4,
    4,3,3,3,3,3,3,3,3,1,1,1,
    1,2,2,2,2,3,3,3,3,4,4,4,
    4 ]

constant(55, "room_count")

# Zero page
label(0x0000, "cell_x")
label(0x0001, "cell_y")
label(0x0002, "sprite_pixel_width_minus_one")
label(0x0003, "sprite_cell_height")
label(0x0005, "delta_x")
label(0x0006, "delta_y")
label(0x0007, "room_decode_sprite")
label(0x0008, "current_room_low")
label(0x0009, "current_room_high")
label(0x000a, "plot_strip_loop_counter")
label(0x000b, "temp_byte")
label(0x000c, "collision_map_byte_to_write")
label(0x000d, "current_room_index")
label(0x000e, "offset_to_start_of_computers")
label(0x000f, "offset_to_start_of_collectibles")

label(0x0011, "current_room_header")
label(0x0013, "room_decode_sprite_height")
label(0x0014, "room_decode_sprite_width")
label(0x0015, "room_decode_rect_width")
label(0x0016, "temp_y")
label(0x0017, "sprite_width_minus_one")
label(0x0018, "sprite_height")
label(0x0019, "number_of_dying_items")
label(0x001a, "player_x")
label(0x001b, "player_y")
label(0x001c, "player_sprite")
label(0x001d, "temp_addr_low")
label(0x001e, "temp_addr_high")
label(0x001f, "number_of_arrows_in_flight")
label(0x0020, "arrow_loop_counter")
label(0x0021, "temp_loop_counter")
label(0x0022, "old_player_x")
label(0x0023, "old_player_y")
label(0x0024, "number_of_key0_held")
label(0x0025, "number_of_key1_held")
label(0x0026, "number_of_key2_held")
label(0x0027, "number_of_key3_held")
label(0x0028, "score_digits_0")
label(0x0029, "score_digits_1")
label(0x002a, "score_digits_2")
label(0x002b, "score_digits_3")
label(0x002c, "score_digits_4")
label(0x002d, "score_digits_5")
label(0x002e, "score_digits_6")
label(0x002f, "print_addr_low")
label(0x0030, "print_addr_high")
label(0x0031, "temp_slash_divisor")
label(0x0032, "energy_bar_level")
label(0x0033, "ammo_bar_level")
label(0x0034, "temp_enemy_count")
label(0x0035, "sound_duration")
label(0x0036, "stack_ptr")
label(0x0037, "number_of_enemies")
label(0x0038, "rnd_rom_addr_low")
label(0x0039, "rnd_rom_addr_high")
label(0x003a, "temp_counter")
label(0x003b, "temp_store_y")
label(0x003c, "rnd_offset")
label(0x003d, "sprite_mask")
label(0x003e, "remember_x")
label(0x003f, "remember_y")
label(0x0040, "computer_bar_level")
label(0x0041, "suppress_sound_flag")
label(0x0042, "music_index")
label(0x0043, "enter_next_room_horizontally")
label(0x0044, "title_offset")
label(0x0045, "half_length_of_room_title")
label(0x00ff, "os_escape_flag")

label(0x0400, "current_room_cache")
label(0x0500, "dying_items")
label(0x0501, "dying_items + 1")
label(0x0502, "dying_items + 2")
label(0x0503, "dying_items + 3")
label(0x0580, "arrow_slots")
label(0x0581, "arrow_slots + 1")
label(0x0582, "arrow_slots + 2")

label(0x0c00, "enemies_state")
label(0x0c01, "enemies_state + 1")
label(0x0c02, "enemies_state + 2")
label(0x0c03, "enemies_state + 3")
label(0x0c04, "enemies_state + 4")
label(0x0c05, "enemies_state + 5")

label(0x0e00, "clock")

# Memory locations
comment(0x1210, "There are 85 sprites. Sprites are stored 8x8 character cells which are ordered upside down and from right to left. The first 32 sprites can be specified in the commands of the room definition.")

def get_addr(addr, x, y, w, h):
    y = y ^ 7
    #y = h - 1 - y
    x = (w - 1) - x
    return addr + int(y/8)*w + int(x/8)*8 + (y & 7)

def centre_row(row):
    split_row = row.splitlines()
    max_width = 0
    for entry in split_row:
        max_width = max(len(entry), max_width)

    for i in range(0, len(split_row)):
        extra_spaces_to_left = int((80 - len(split_row[i])) / 2)
        if extra_spaces_to_left > 0:
            split_row[i] = " "*extra_spaces_to_left + split_row[i]
        split_row[i] = split_row[i].rstrip()

    return "\n".join(split_row)


# Append a multiline ASCII sprite to the right of an existing sequence of ASCII sprites in a row
def append_string(row, row_width, string):
    split_row = row.splitlines()
    max_width = 0
    for entry in split_row:
        max_width = max(len(entry), max_width)

    # make sure there are enough rows
    split_string = string.splitlines()
    extra_rows = len(split_string) - len(split_row)
    while (extra_rows > 0):
        split_row.append("")
        extra_rows -= 1

    # make sure they are all the same width
    for i in range(0, len(split_row)):
        extra_spaces_to_add = max_width - len(split_row[i])
        split_row[i] += " "*extra_spaces_to_add

    # append to each row
    for i in range(0, len(split_string)):
        split_row[i] += split_string[i]
    return "\n".join(split_row)

def setc(string, i, val):
    return string[:i] + val + string[i+1:]

gallery_gap = 6

i = 0
addr = 0x1210
row = ""
row_width = 0
row_height = 0
for i in range(0, 85):
    stri = str(i)
    picture_sprite(addr, "sprite" + stri, 8, sprite_widths[i] * sprite_heights[i] * 8)

    # ASCII art
    span = 1 + (8 * sprite_widths[i])
    byte_string = '?' * (span * 8 * sprite_heights[i])
    for y in range(0, 8 * sprite_heights[i]):
        for x in range(0, 8 * sprite_widths[i]):
            test_addr = get_addr(addr, x, y, 8 *sprite_widths[i], 8 * sprite_heights[i])
            by = get_u8(test_addr)
            bit = (128 >> (x & 7))
            if by & bit:
                c = '#'
            else:
                c = ' '
            byte_string = setc(byte_string, x + y*span, c)
        byte_string = setc(byte_string, (y + 1)*span - 1, '\n')

    framed_string = "/" + "-"*8 * sprite_widths[i] + "\\"  + " "*gallery_gap + "\n"
    for line in byte_string.splitlines():
        line = "|" + line + "|" + " "*gallery_gap
        framed_string += line + "\n"
    framed_string += "\\" + "-"*8 * sprite_widths[i] + "/" + " "*gallery_gap
    frame_width = 1 + 8 * sprite_widths[i] + 1
    title_width = len("sprite" + str(i))
    left_space = int((frame_width - title_width) / 2)
    right_space = frame_width - left_space - title_width
    framed_string += "\n" + " " * left_space + "sprite" + str(i) + " "*right_space + " "*gallery_gap + "\n\n"

    # Start a new row?
    if ((row_width + frame_width) >= 80) or ((row_height != 0) and (row_height != sprite_heights[i])):
        row = centre_row(row)
        formatted_comment(0x1210, "\n" + row)
        row = ""
        row_width = 0
        row_height = 0

    row = append_string(row, row_width, framed_string)
    row_width += frame_width + gallery_gap
    row_height = sprite_heights[i]

    # Move on to next sprite
    addr += sprite_heights[i] * 8 * sprite_widths[i]
    i = i + 1

if (row != ""):
    row = centre_row(row)
    formatted_comment(0x1210, "\n" + row)

comment(0x1fe8, "Width (in pixels) of each sprite")
comment(0x203d, "Height (in character cells) of each sprite")
label(0x1fe8, "sprite_width_table")
byte(0x1fe8, 85)
label(0x203d, "sprite_height_table")
byte(0x203d, 85)

comment(0x2092, "The address of each sprite, stored as offsets from sprite_0")
label(0x2092, "sprite_offset_table_low")
byte(0x2092, 85)
label(0x20e7, "sprite_offset_table_high")
byte(0x20e7, 85)
label(0x0600, "highscore_table_names")
label(0x6fa, "highscore_table_scores")

label(0x394b, "room_definition_low")
label(0x3982, "room_definition_high")

room = [[]]

def start_room():
    global room
    global deltax
    global deltay
    global cellx
    global celly
    global sprite
    global skip_first_sprite_plot

    rows, cols = (32, 40)
    room = []
    for i in range(rows):
        col = []
        for j in range(cols):
            col.append(-1)
        room.append(col)

    cellx = 0
    celly = 6
    deltax = 1
    deltay = 0
    sprite = 1
    skip_first_sprite_plot = False

def end_room(addr, room_title):
    global room

    comment_str = "\n"
    width = 0
    for row in room:
        for sprite in row:
            if sprite == 20:
                comment_str += "|"
            elif sprite == 43:
                comment_str += "D"
            elif sprite == 48:
                comment_str += "D"
            elif sprite == 32:
                comment_str += "1"
            elif sprite == 33:
                comment_str += "2"
            elif sprite == 34:
                comment_str += "3"
            elif sprite == 35:
                comment_str += "4"
            elif sprite == 57:
                comment_str += "C"
            elif sprite == 58:
                comment_str += "c"
            elif sprite == 59:
                comment_str += "X"
            elif sprite == 60:
                comment_str += "x"

            elif sprite == 38:
                comment_str += "O"
            elif sprite == 39:
                comment_str += "S"
            elif sprite == 40:
                comment_str += "A"
            elif sprite == 26 or sprite == 27:
                comment_str += "="
            elif sprite == 256:
                comment_str += "K"

            elif sprite >= 0 and sprite != 21 and sprite != 47 and sprite != 52:
                comment_str += "*"
            else:
                comment_str += "."
        comment_str += "\n"
    comment_str = comment_str.rstrip("\n")

    # Strip off first six rows of top empty space
    if comment_str.startswith("\n........................................\n........................................\n........................................\n........................................\n........................................\n........................................\n"):
        comment_str = comment_str[246:]

    # Add title, centred
    blank(addr)
    comment_str = " "*(19-len(room_title)//2) + room_title + comment_str

    # Add comment
    formatted_comment(addr, comment_str)

def plot_sprite(addr, sprite, x, y):
    global room

    if sprite == 256:
        room[y][x] = sprite
        return

    for w in range(0, sprite_widths[sprite]):
        for h in range(0, sprite_heights[sprite]):
            room[y+h][x+w] = sprite

def add_door(addr,door_type,doorx,doory,vertical,visible):

    if not visible:
        if vertical:
            plot_sprite(addr, 47, doorx, doory + 1)
        else:
            plot_sprite(addr, 52, doorx + 1, doory)
        return

    plot_sprite(addr, 32 + door_type, doorx, doory)
    if vertical:
        if visible:
            plot_sprite(addr, 43, doorx, doory + 1)
        plot_sprite(addr, 32 + door_type, doorx, doory + 5)
    else:
        if visible:
            plot_sprite(addr, 48, doorx + 1, doory)
        if (doorx + 5) >= 40:
            doorx -= 40
            doory += 1
        if doory < 32:
            plot_sprite(addr, 32 + door_type, doorx + 5, doory)

def add_key(addr,keyx,keyy,key_index):
    plot_sprite(addr, 256, keyx, keyy)
    plot_sprite(addr, 32+key_index, keyx, keyy + 1)

def add_computer(addr,x,y,index):
    plot_sprite(addr, 0x39+index, x, y)

def add_collectible(addr,x,y,index):
    plot_sprite(addr, 0x25+index, x, y)

def command_plot_strip(addr):
    global cellx
    global celly
    global sprite
    global skip_first_sprite_plot

    length = get_u8(addr)
    byte(addr, 1)
    comment(addr, "plot strip at {x},{y} of length {l}".format(x=cellx, y=celly,l=length), inline=True)

    if not skip_first_sprite_plot:
        plot_sprite(addr, sprite, cellx, celly)
        length -= 1

    skip_first_sprite_plot = True

    for i in range(0, length):
        cellx += deltax
        celly += deltay
        plot_sprite(addr, sprite, cellx, celly)
#    print("Done",addr,cellx,celly)
    return 1

def command_set_deltax_or_y(addr):
    global deltax
    global deltay

    byt = get_u8(addr)
    delta = byt & 7
    if (byt & 8) != 0:
        delta = -delta
    if (byt & 16) == 0:
        deltax = delta
        deltay = 0
        comment(addr, "set delta to {d},0".format(d=delta), inline=True)
    else:
        deltay = delta
        deltax = 0
        comment(addr, "set delta to 0,{d}".format(d=delta), inline=True)
    byte(addr, 1)
    return 1

def command_set_cellxy(addr):
    global cellx
    global celly
    global skip_first_sprite_plot

    celly = get_u8(addr) & 0x1f
    cellx = get_u8(addr + 1)
    byte(addr, 2)
    comment(addr, "set position to {x},{y}".format(x=cellx,y=celly), inline=True)
    skip_first_sprite_plot = False
    return 2

def command_move_in_delta_direction(addr):
    global cellx
    global celly

    size = get_u8(addr) & 0x1f
    cellx += deltax * size
    celly += deltay * size
    comment(addr, "move by {s}*delta to {x},{y}".format(x=cellx,y=celly,s=size), inline=True)
    return 1

def command_set_sprite(addr):
    global sprite

    byt = get_u8(addr)
    sprite = byt & 0x1f
    if byt >= 128:
        if sprite == 31:
            collision_byte = 0
        else:
            collision_byte = 0x90
    else:
        collision_byte = 0x80
    comment(addr, "set sprite {s}, collision byte {c}".format(s=sprite,c=collision_byte), inline=True)
    return 1

def command_move_draw_rect(addr):
    global skip_first_sprite_plot
    global celly

    rect_height = get_u8(addr) & 0x1f
    rect_width  = get_u8(addr + 1)
    skip_first_sprite_plot = False
    byte(addr, 2)
    comment(addr, "draw rect from {x},{y} with size {w}x{h}".format(x=cellx,y=celly,w=rect_width,h=rect_height), inline=True)
    for y in range(celly, celly + rect_height):
        for x in range(cellx, cellx + rect_width):
            plot_sprite(addr, sprite, x, y)
    celly = y+1
    return 2

def execute_command(command, addr):
    if command == 0:
        return command_plot_strip(addr)
    elif command == 1:
        return command_plot_strip(addr)
    elif command == 2:
        return command_set_sprite(addr)
    elif command == 3:
        return command_set_deltax_or_y(addr)
    elif command == 4:
        return command_set_cellxy(addr)
    elif command == 5:
        return command_move_in_delta_direction(addr)
    elif command == 6:
        return command_set_sprite(addr)
    elif command == 7:
        return command_move_draw_rect(addr)

    return 1

addr_low = 0x394b
addr_high = 0x3982
for i in range(0,55):
    addr = get_u8(addr_low) + 256 * get_u8(addr_high)
    name = "room_" + str(i) + "_definition"
    label(addr, name)
    byte(addr, 1)
    comment(addr, "offset to start of doors", True)
    byte(addr + 1, 4)
    byte(addr + 5, 1)
    comment(addr + 1, "four enemy types", True)
    comment(addr + 5, "max enemies to show is " + str(get_u8(addr+5)), True)

    start_room()

    # Decode room commands
    start_addr = addr
    addr = addr + 6

    command_byte = get_u8(addr)
    while True:
        if command_byte == 0:
            byte(addr, 1)
            comment(addr, "terminator for commands", inline=True)
            addr += 1
            break
        command = command_byte >> 5
        addr += execute_command(command, addr)
        command_byte = get_u8(addr)

    # Decode doors
    command_byte = get_u8(addr)
    while True:
        if command_byte == 0:
            byte(addr, 1)
            comment(addr, "terminator for doors", inline=True)
            addr += 1
            break

        door_info = get_u8(addr)
        doorx = get_u8(addr + 1)
        doory = get_u8(addr + 2)
        dest_door_index = get_u8(addr + 3)
        dest_room_index = get_u8(addr + 4)
        door_type = (door_info >> 3) & 3

        byte(addr, 5)
        vis = (door_info & 32) != 0
        if vis:
            com = "visible "
        else:
            com = "invisible "
        if ((door_info & 64) != 0):
            add_door(addr, door_type, doorx, doory, vertical=True, visible=vis)
            com += "vertical door at " + str(doorx) + "," + str(doory)
        else:
            add_door(addr, door_type, doorx, doory, vertical=False, visible=vis)
            com += "horizontal door at " + str(doorx) + "," + str(doory)
        if dest_room_index != 255:
            com += " to door " + str(dest_door_index) + " in room " + str(dest_room_index)
        comment(addr, com, inline=True)
        addr += 5
        command_byte = get_u8(addr)

    # Decode keys
    command_byte = get_u8(addr)
    while True:
        if command_byte == 0:
            byte(addr, 1)
            comment(addr, "terminator for keys", inline=True)
            addr += 1
            break
        keyy = get_u8(addr + 2)
        keyx = get_u8(addr + 1)
        key_index = command_byte & 3

        byte(addr, 3)
        add_key(addr, keyx, keyy, key_index)
        comment(addr, "key at " + str(keyx) + "," + str(keyy), inline=True)
        addr += 3
        command_byte = get_u8(addr)

    # Decode computers
    command_byte = get_u8(addr)
    while True:
        if command_byte == 0:
            byte(addr, 1)
            comment(addr, "terminator for computers", inline=True)
            addr += 1
            break
        computery = get_u8(addr + 2)
        computerx = get_u8(addr + 1)
        computer_index = command_byte & 3

        byte(addr, 3)
        add_computer(addr, computerx, computery, computer_index)
        comment(addr, "computer type " + str(computer_index) + " at " + str(computerx) + "," + str(computery), inline=True)
        addr += 3
        command_byte = get_u8(addr)

    # Decode collectibles
    command_byte = get_u8(addr)
    while True:
        if command_byte == 0:
            byte(addr, 1)
            comment(addr, "terminator for collectibles", inline=True)
            addr += 1
            break
        collectibley = get_u8(addr + 2)
        collectiblex = get_u8(addr + 1)
        collectible_index = command_byte & 3

        byte(addr, 3)
        add_collectible(addr, collectiblex, collectibley, collectible_index)
        comment(addr, "collectible at " + str(collectiblex) + "," + str(collectibley), inline=True)
        addr += 3
        command_byte = get_u8(addr)

    # Decode title
    command_byte = get_u8(addr)
    title_addr = addr
    room_title = ""
    while True:
        if command_byte == 0:
            byte(addr, 1)
            comment(addr, "terminator for title", inline=True)
            addr += 1
            break

        if command_byte >= 128:
            room_title += chr(command_byte & 0x7f)
            break
        else:
            room_title += chr(command_byte)
        addr += 1
        command_byte = get_u8(addr)

    if room_title != "":
        comment(title_addr, "\"" + room_title + "\"", inline=True)
    end_room(start_addr, room_title)

    expr(addr_low, "<" + name)
    expr(addr_high, ">" + name)
    byte(addr_low, 1)
    byte(addr_high, 1)
    addr_low += 1
    addr_high += 1

divider = "***************************************************************************************"

def sublabel(addr, lab, com = ""):
    formatted_comment(addr, divider)
    if com != "":
        comment(addr, com)
    label(addr, lab)

sublabel(0x3b76, "get_random_byte", "read the next byte from ROM, preserving X and Y")
label(0x3b8a, "skip_reset_rnd_addr")
formatted_comment(0x3b8f, divider + """
Each enemy state has 6 bytes:
    byte 0 = zero means not used, otherwise:
        bits 0-1: dissolve animation step
        bits 2-4: countdown to changing direction
        bit 5   : alive?
        bit 6   : ?
        bit 7   : currently dissolving flag
    byte 1 = x cell position
    byte 2 = y cell position
    byte 3 = delta X
    byte 4 = delta Y
    byte 5 = sprite number""")

label(0x3b8f, "update_enemies_appearing")
label(0x3bcc, "next_enemy")
label(0x3bc8, "decrement_loop_counter")
label(0x3b97, "update_enemies_appearing_loop")
comment(0x3b9a, "if not used, then branch", True)
comment(0x3b9c, "if not dissolving, then branch", True)
comment(0x3ba0, "if finished dissolving, branch", True)
comment(0x3ba3, "choose which dissolving sprite to plot", True)
comment(0x3ba7, "enemy sprite number", True)
comment(0x3bad, "get enemy X position", True)
comment(0x3bb0, "get enemy Y position", True)

sublabel(0x3bd4, "update_enemy_spawn")
label(0x3be0, "no_spawn")
label(0x3bef, "clear_direction_draw_enemy_and_update_animation")
comment(0x3bf6, "set enemy delta X", True)
comment(0x3bf9, "set enemy delta Y", True)
label(0x3bfe, "draw_enemy_and_update_animation")
comment(0x3c0f, "fall through...")
label(0x3c0f, "draw_enemy_and_update_animation_2")
comment(0x3c0f, "enemy sprite number", True)
comment(0x3c15, "get enemy position (X,Y)", True)
comment(0x3c18, "get enemy Y position", True)
comment(0x3c26, "get enemy sprite number", True)
comment(0x3c2c, "get enemy sprite number", True)
comment(0x3c36, "get enemy sprite number", True)
comment(0x3c3c, "get enemy sprite number", True)
label(0x3c3f, "done_animation")
label(0x3c4c, "spawn")
comment(0x3c4c, "get enemy sprite number", True)
comment(0x3c4f, "get enemy X position", True)
comment(0x3c54, "get enemy Y position", True)
label(0x3c6d, "move_enemy_if_possible")
comment(0x3c6e, "get enemy X position", True)
comment(0x3c71, "add enemy delta X", True)
comment(0x3c7f, "get enemy Y position", True)
comment(0x3c82, "add enemy delta Y", True)
comment(0x3c99, "set enemy X position", True)
label(0x3ca6, "done_moving_enemy")
label(0x3ca9, "not_suitable_for_moving_enemy")
label(0x3cb0, "set_random_new_direction")
comment(0x3cb8, "set the new 'countdown to change in direction' and other flags", True)
comment(0x3cbb, "choose a new random direction", True)
comment(0x3cc4, "set enemy delta X", True)
comment(0x3cca, "set enemy delta Y", True)

sublabel(0x3cd0, "enemy_dies")
comment(0x3cd7, "enemy sprite number", True)
comment(0x3cda, "get enemy X position", True)
comment(0x3cde, "get enemy Y position", True)

sublabel(0x3cf4, "is_collision_map_empty_here", "carry clear if the collision map is empty at (cell_x,cell_y) with size delta_x square")
expr(0x3cfa, "collision_map_addr_low - 5")
expr(0x3d01, "collision_map_addr_high - 5")
label(0x3d0b, "collision_map_check_rows_loop")
label(0x3d0f, "collision_map_check_columns_loop")
label(0x3d23, "collision_map_not_empty")
label(0x3d25, "done")
label(0x3d28, "check_enemy_spawn_position_clear")
formatted_comment(0x3d28, divider + "\nreturn with carry clear if the requested spawn position is available")
label(0x3d4c, "check_collision_map_column_available")
label(0x3f54, "draw_bar_loop")
label(0x3d5a, "collision_map_check_rows_available_loop")
label(0x3d78, "check_row_available_loop")
comment(0x3d82, "collision map is clear so spawn point is valid", True)
label(0x3d86, "no_spawn_position_found")
label(0x3d85, "not_found")
label(0x3d87, "spawn_position_found")
label(0x3d8a, "pull_a_and_return")
expr(0x3d91, "current_room_cache + 5")
comment(0x3d28, "enemy sprite number", True)
comment(0x3d34, "get enemy X position", True)
comment(0x3d37, "get enemy Y position", True)
expr(0x3d3d, "collision_map_addr_low - 5")
expr(0x3d44, "collision_map_addr_high - 5")

sublabel(0x3d8c, "update_enemies")
label(0x3d95, "update_enemies_loop")
label(0x3da1, "update_enemy")
comment(0x3da6, "get enemy X position", True)
comment(0x3dae, "get enemy Y position", True)
comment(0x3dc4, "enemy sprite number", True)
comment(0x3dc7, "get enemy X position", True)
comment(0x3dd3, "get enemy Y position", True)
expr(0x3dea, "collision_map_addr_low - 5")
label(0x3dfb, "check_clear_loop")
label(0x3e12, "done_checking_clear")
label(0x3dff, "check_row_clear_loop")
comment(0x3e21, "enemy sprite number", True)
label(0x3e3e, "delta_x_table")
label(0x3e46, "delta_y_table")

sublabel(0x3e4e, "print_following_string")
hook_subroutine(0x3e4e, "print_following_string", hook)
label(0x3e56, "print_loop")
label(0x3e6a, "increment_print_address")
sublabel(0x3e71, "print_decimal_number")
sublabel(0x3e8d, "divide")

expr(0x3df1, "collision_map_addr_high - 5")
label(0x3e78, "divide_by_ten_loop")
label(0x3e83, "print_digit_loop")
label(0x3e91, "divide_loop")
label(0x3e9c, "divide_next_bit")
sublabel(0x3ea0, "show_keys_and_zero_score")

entry(0x3eeb, "print_keys")
label(0x3eef, "print_keys_loop")
expr(0x3f0b, "'0'")

sublabel(0x3f1d, "increment_computer_bar")
expr(0x3f1e, "<computer_bar_screen_address")
expr(0x3f20, ">computer_bar_screen_address")

blank(0x3f27)
sublabel(0x3f27, "increment_energy_bar")
expr(0x3f28, "<energy_bar_screen_address")
expr(0x3f2a, ">energy_bar_screen_address")
expr(0x3f2e, "100")

blank(0x3f35)
sublabel(0x3f35, "increment_ammo_bar")
expr(0x3f36, "<ammo_bar_screen_address")
expr(0x3f38, ">ammo_bar_screen_address")
label(0x3f42, "draw_bar")
label(0x3f5b, "bar_pixels_set_table")
expr(0x3f4f, "bar_pixels_set_table + 1")
label(0x3f9d, "draw_bar_loop2")
label(0x3fa3, "check_energy")
sublabel(0x3fad, "refill_bars")
label(0x3fb7, "refill_bars_loop")

sublabel(0x3f64, "decrement_computer_bar")
expr(0x3f65, "<computer_bar_screen_address")
expr(0x3f67, ">computer_bar_screen_address")
sublabel(0x3f6f, "decrement_energy_bar")
expr(0x3f79, "<energy_bar_screen_address")
expr(0x3f7b, ">energy_bar_screen_address")

sublabel(0x3f7e, "decrement_ammo_bar")
expr(0x3f87, "<ammo_bar_screen_address")
expr(0x3f89, ">ammo_bar_screen_address")
label(0x3f8b, "print_decremented_bar")
comment(0x3fa7, "out of energy")
expr(0x3fb4, "100")
label(0x3fe3, "print_score")
label(0x3fcc, "add_to_score_loop")
label(0x3fca, "add_a_to_score")

sublabel(0x3fc8, "increment_score")
label(0x3ff4, "print_score_loop")

sublabel(0x3ffe, "wait")
label(0x4017, "wait_clock_read_value")
label(0x401c, "wait_clock_write_value")
sublabel(0x401d, "check_sound_on_off")
label(0x4028, "skip")
sublabel(0x4034, "check_paws")
label(0x404c, "paws_loop")

sublabel(0x4065, "check_play_sound_a")
label(0x406c, "pull_and_play_sound_a")
label(0x406d, "play_sound_a")
expr(0x407b, "osword_sound")

label(0x4083, "skip_sound")
label(0x4088, "sound_addr_table_low")
expr(0x4088, "<sound0")
expr(0x4089, "<sound1")
expr(0x408a, "<sound2")
expr(0x408b, "<sound3")
expr(0x408c, "<sound4")
expr(0x408d, "<sound5")
expr(0x408e, "<sound6")
expr(0x408f, "<sound7")
expr(0x4090, "<sound8")
label(0x4091, "sound_addr_table_high")
byte(0x4091, 0x4091-0x4088)
expr(0x4091, ">sound0")
expr(0x4092, ">sound1")
expr(0x4093, ">sound2")
expr(0x4094, ">sound3")
expr(0x4095, ">sound4")
expr(0x4096, ">sound5")
expr(0x4097, ">sound6")
expr(0x4098, ">sound7")
expr(0x4099, ">sound8")
label(0x409a, "sound0")
byte(0x409a, 8)
label(0x409a + 1*8, "sound1")
byte(0x409a + 1*8, 8)
label(0x409a + 2*8, "sound2")
byte(0x409a + 2*8, 8)
label(0x409a + 3*8, "sound3")
byte(0x409a + 3*8, 8)
label(0x409a + 4*8, "sound4")
byte(0x409a + 4*8, 8)
label(0x409a + 5*8, "sound5")
byte(0x409a + 5*8, 8)
label(0x409a + 6*8, "sound6")
byte(0x409a + 6*8, 8)
label(0x409a + 7*8, "sound7")
byte(0x409a + 7*8, 8)
label(0x409a + 8*8, "sound8")
byte(0x409a + 8*8, 8)
label(0x40c8, "sound5_duration")
label(0x40d0, "sound6_duration")
label(0x40d6, "sound7_pitch")
blank(0x40e2)
sublabel(0x40e2, "collision_map_addr_low")
byte(0x40e2, 27)
label(0x40fd, "collision_map_addr_high")
byte(0x40fd, 27)
blank(0x4118)
sublabel(0x4118, "room_decoder_routine_table_low")
expr(0x4118, "<room_decode_plot_strip")
expr(0x4119, "<room_decode_plot_strip")
expr(0x411a, "<room_decode_set_sprite")
expr(0x411b, "<room_decode_set_deltax_or_y")
expr(0x411c, "<room_decode_set_cellxy")
expr(0x411d, "<room_decode_move_in_delta_direction")
expr(0x411e, "<room_decode_set_sprite")
expr(0x411f, "<room_decode_draw_rect")

label(0x4120, "room_decoder_routine_table_high")
byte(0x4120, 8)
expr(0x4120, ">room_decode_plot_strip")
expr(0x4121, ">room_decode_plot_strip")
expr(0x4122, ">room_decode_set_sprite")
expr(0x4123, ">room_decode_set_deltax_or_y")
expr(0x4124, ">room_decode_set_cellxy")
expr(0x4125, ">room_decode_move_in_delta_direction")
expr(0x4126, ">room_decode_set_sprite")
expr(0x4127, ">room_decode_draw_rect")

sublabel(0x4128, "clear_memory")
label(0x4130, "clear_memory_loop")
sublabel(0x414b, "decode_room_commands")
label(0x4166, "copy_current_room_data_to_cache_loop")
comment(0x416e, "handle all room commands")
label(0x4170, "decode_room_commands_loop")
label(0x418b, "opcode1")
label(0x418c, "routine_addr_low")
label(0x418d, "routine_addr_high")
sublabel(0x4192, "prepare_room")
label(0x419a, "prepare_doors_loop")
blank(0x419f)
formatted_comment(0x419f, """copy five bytes of door information (reversing the order!) to zero page:
    0x11: destination room index
    0x12: destination door index
    0x13: y cell position
    0x14: x cell position
    0x15: current_room_door_info""")

label(0x41a1, "copy_door_info_loop")
blank(0x41aa)
formatted_comment(0x41aa, """Reset current door information, if needed.
  current_room_door_info:
    bit 7    = door is open flag
    bit 6    = door is vertical flag
    bit 5    = door is present flag
    bits 3-4 = door type (0-3)
    bits 0-2 = door animation stage 0-4, 0=closed, 4=open""")
comment(0x41ac, "if top bit clear then branch (animation doesn't need resetting)", True)
expr(0x41b3, "current_room_cache - 5")
comment(0x41ae, "remove top bit and bottom three bits", True)
comment(0x41b0, "set bit 2, i.e. door is in open animation state", True)

label(0x41b7, "skip_reset_bits")
comment(0x41b7, "temp storage for Y", True)
comment(0x41b9, "check bit 5", True)
comment(0x41bb, "if bit 5 clear then branch", True)
label(0x41e6, "draw_door_itself")
comment(0x41d8, "if door is horizontal then branch", True)
blank(0x41bd)
comment(0x41bd, "render the door type squares above and below the door")
comment(0x41c2, "A = door type", True)
comment(0x41c5, "add 32 to get sprite number of door type", True)
label(0x41e1, "got_door_coordinates")
label(0x41f2, "skip_door_fully_open")
comment(0x41fb, "add 48 to get sprite for horizontal door", True)
comment(0x41fe, "ALWAYS branch", True)
comment(0x4200, "add 43 to get sprite for vertical door", True)
label(0x4200, "vertical_door")
label(0x4203, "plot_door_sprite")
blank(0x420e)
label(0x420e, "plot_keys")
label(0x4215, "plot_keys_loop")
comment(0x4225, "plot down arrow", True)
label(0x4230, "next_key")
label(0x4236, "plot_computers")
label(0x423d, "plot_computers_loop")
comment(0x4247, "plot computer", True)
label(0x4251, "next_computer")
comment(0x4254, "ALWAYS branch", True)
blank(0x4256)
label(0x4256, "plot_collectibles")
label(0x425d, "plot_collectibles_loop")
comment(0x4267, "plot collectible", True)
label(0x4271, "next_collectible")
comment(0x4274, "ALWAYS branch", True)
blank(0x4276)
label(0x4276, "plot_room_title")
label(0x4288, "count_room_title_length")
label(0x429c, "print_x_spaces_loop")
label(0x42a6, "print_room_name_loop")
label(0x42b1, "print_room_name_final_character")
label(0x42b6, "print_spaces_to_end_of_line")
expr(0x42d7, "current_room_cache - 1")
label(0x42e0, "set_deltax")
label(0x42e3, "negative_delta")
label(0x42d5, "set_delta")

formatted_comment(0x42c5, divider)
entry(0x42c5, "room_decode_set_deltax_or_y")

formatted_comment(0x42ef, divider)
entry(0x42ef, "room_decode_set_cellxy")

formatted_comment(0x42ff, divider)
entry(0x42ff, "room_decode_set_sprite")
comment(0x42ff, "redundant", True)
comment(0x4301, "use collision map value $80 if A>=0", True)
comment(0x4307, "use collision map value $90 if A!=$95 ($95=128+sprite 21, the empty sprite)", True)
comment(0x430f, "use collision map value $00 if A=$95 (the empty sprite)", True)
label(0x4311, "set_sprite_a_and1f_and_collision_x")
label(0x4313, "set_sprite_a_and_collision_x")

formatted_comment(0x4319, divider)
entry(0x4319, "room_decode_draw_rect")
comment(0x431b, "rectangle height", True)
comment(0x4321, "rectangle width", True)
label(0x4335, "loop_plot_rect_outer")
label(0x433c, "loop_plot_rect_inner")
comment(0x433c, "cell offset for deleting behind the sprite", True)

formatted_comment(0x4361, divider)
entry(0x4361, "room_decode_plot_strip")
label(0x437b, "room_plot_at_first_position")

formatted_comment(0x4388, divider)
entry(0x4388, "room_decode_move_in_delta_direction")
label(0x438b, "move_in_delta_loop")

formatted_comment(0x439e, divider)
entry(0x439e, "plot_room_sprite_xy")
label(0x43a2, "plot_room_sprite")
label(0x43a7, "plot_room_sprite_a_to_collision_map")
label(0x436d, "plot_strip_loop")
label(0x43c9, "write_collision_map_loop")
label(0x43cf, "collision_map_dest_low")
label(0x43d0, "collision_map_dest_high")
label(0x43ce, "inner_loop")
expr(0x43ae, "collision_map_addr_low - 5")
expr(0x43b4, "collision_map_addr_high - 5")

sublabel(0x43e8, "clear_play_area")
label(0x43f3, "play_area_screen_addr_high")
label(0x43f1, "clear_play_area_loop")
sublabel(0x4402, "update_collision_map_at_player")
expr(0x4408, "collision_map_addr_low - 5")
expr(0x440d, "collision_map_addr_high - 5")

formatted_comment(0x4431, divider)
label(0x4431, "screen_address_table_low")
label(0x4451, "screen_address_table_high")

addr_low = 0x4431
addr_high = 0x4451
for i in range(0,32):
    expr(addr_low, "<($5800 + " + str(i) + " * $0140)")
    expr(addr_high, ">($5800 + " + str(i) + " * $0140)")
    byte(addr_low, 1)
    byte(addr_high, 1)
    addr_low += 1
    addr_high += 1

label(0x4415, "eor_top_two_bits_loop")
label(0x4417, "eor_top_two_bits_internal_loop")
sublabel(0x4471, "get_sprite_a_address")
expr(0x4482, "<sprite0")
expr(0x4488, ">sprite0")
sublabel(0x448b, "get_xy_screen_address")
sublabel(0x44a9, "plot_sprite_xy_set")
label(0x44ad, "plot_sprite_set")
label(0x44c1, "plot_loop_set")
label(0x44c3, "plot_internal_loop_set")
label(0x44c4, "source1_sprite_addr_low")
label(0x44c5, "source1_sprite_addr_high")
label(0x44c6, "opcode2")
label(0x44c7, "dest1_screen_addr_low")
label(0x44c8, "dest1_screen_addr_high")

sublabel(0x44e4, "plot_sprite_xy_and")
label(0x4502, "plot_loop_and")
label(0x4504, "opcode3")
label(0x4505, "source2_sprite_addr_low")
label(0x4506, "source2_sprite_addr_high")
label(0x4507, "opcode4")
label(0x4508, "mask2_sprite_addr_low")
label(0x4509, "mask2_sprite_addr_high")
label(0x450a, "opcode5")
label(0x450b, "dest2_screen_addr_low")
label(0x450c, "dest2_screen_addr_high")

sublabel(0x452e, "plot_sprite_xy_clear")
label(0x4544, "plot_loop_clear")
label(0x4548, "plot_internal_loop_clear")
label(0x4549, "opcode6")
label(0x454a, "dest3_screen_addr_low")
label(0x454b, "dest3_screen_addr_high")

sublabel(0x4565, "plot_sprite_xy_eor")
label(0x4569, "plot_sprite_eor")
label(0x4583, "plot_loop_eor")
label(0x4585, "plot_internal_loop_eor")
label(0x4586, "source4_sprite_addr_low")
label(0x4587, "source4_sprite_addr_high")
label(0x4588, "opcode7")
label(0x4589, "mask4_sprite_addr_low")
label(0x458a, "mask4_sprite_addr_high")
label(0x458b, "opcode8")
label(0x458c, "dest4_screen_addr_low")
label(0x458d, "dest4_screen_addr_high")

sublabel(0x45af, "plot_sprite_xy_mask")
expr(0x45cc, "<sprite0")
expr(0x45d4, ">sprite0")
label(0x45da, "plot_loop_mask")
label(0x45dc, "plot_internal_loop_mask")
label(0x45e3, "screen_addr_low")
label(0x45e4, "screen_addr_high")
label(0x45dd, "sprite_addr_low")
label(0x45de, "sprite_addr_high")
label(0x45df, "opcode9")
label(0x45e0, "sprite_mask_addr_low")
label(0x45e1, "sprite_mask_addr_high")
label(0x45e2, "opcode10")

sublabel(0x4600, "update_doors")
label(0x4603, "update_doors_loop")
label(0x461e, "horizontal_door")
label(0x4635, "next_door1")
label(0x463c, "door_finished_opening")

sublabel(0x4650, "get_next_two_room_bytes_into_xy")

sublabel(0x465c, "add_dying_item")
label(0x4663, "add_dying_item_loop")
label(0x466e, "found_dying_item_free_slot")
comment(0x46b9, "dissolve away", True)
sublabel(0x468a, "update_dying_items")
label(0x4692, "update_dying_items_loop")
label(0x46c2, "check_if_done")
label(0x46c6, "next_dying_item")

sublabel(0x46cd, "remove_fully_dissolved_object")

sublabel(0x46e7, "update_player")
label(0x46fe, "skip_animation_reset")
label(0x4704, "store_player_sprite")
label(0x4706, "skip_store_player_sprite")
label(0x4736, "check_for_collision_vertical_loop")
label(0x4738, "check_for_collision_horizontal_loop")
label(0x474d, "finished_collision_check")

sublabel(0x4750, "check_for_collisions")
label(0x4759, "check_collectibles_collision_loop")
comment(0x476c, "ALWAYS branch", True)
blank(0x476e)
label(0x476e, "overlaps_in_x")
label(0x477c, "collect")
label(0x47ab, "increment_energy_loop")
label(0x47b4, "increment_ammo_loop")
label(0x47bd, "check_next_collectible")
comment(0x47c0, "ALWAYS branch", True)
blank(0x47c2)
label(0x47c2, "check_keys_collision")
label(0x47c4, "check_keys_collision_loop")
label(0x47e3, "key_taken")
label(0x4826, "check_next_key")
comment(0x4829, "ALWAYS branch", True)
label(0x482b, "write_to_collision_map")
label(0x4836, "check_fire_key_local")
label(0x4839, "check_ZXShift_keys")
label(0x4843, "not_Z")
label(0x484d, "not_X")
label(0x4857, "not_Shift")

label(0x485a, "check_fire_key")
label(0x4868, "check_fire_key_done")

sublabel(0x486b, "handle_fire_key_pressed")
comment(0x486b, "each arrow is stored in three bytes, the first byte has bottom bit for active/dead, and top bit for left/right direction, bytes two and three are the X,Y position")
label(0x486d, "find_free_arrow_slot_loop")
label(0x4877, "got_free_arrow_slot")
comment(0x4890, "if player is facing left then branch", True)
comment(0x4892, "make arrow right facing")

label(0x48a0, "skip_make_arrow_right_facing")

sublabel(0x48b4, "handle_z_pressed")
label(0x48c0, "skip_turn_left")
label(0x48dc, "change_room_local")

sublabel(0x48df, "handle_x_pressed")
label(0x48eb, "skip_turn_right")
expr(0x4948, "collision_map_addr_low - 5")
expr(0x494f, "collision_map_addr_high - 5")

sublabel(0x4909, "handle_shift_pressed")

sublabel(0x4925, "update_falling")

sublabel(0x4941, "get_player_collision_address")

sublabel(0x4954, "read_key")

sublabel(0x495b, "draw_arrows")
label(0x4963, "draw_arrows_loop")
label(0x4970, "left_facing_arrow")
label(0x4985, "next_arrow")

sublabel(0x498b, "update_all_arrows")
label(0x4998, "update_all_arrows_loop")
expr(0x4e9d, "clock + 1")
label(0x49a7, "increment_arrow_x")
label(0x49b3, "next_arrow2")

sublabel(0x49b9, "update_arrow")
expr(0x49cb, "collision_map_addr_low - 5")
expr(0x49d2, "collision_map_addr_high - 5")
label(0x49e2, "draw_arrow")
comment(0x49e2, "X = left facing arrow sprite", True)
comment(0x49e7, "if arrow points left, branch (draw left facing arrow)", True)
comment(0x49e9, "X = right facing arrow sprite", True)
label(0x49ea, "draw_arrow_sprite_x")
comment(0x49ec, "get x,y coordinates of arrow", True)
label(0x49f7, "arrow_finished")
label(0x49ff, "check_for_arrow_colliding_with_collectibles")
label(0x4a17, "collectible_loop")
label(0x4a44, "next_collectible2")

blank(0x4a49)
label(0x4a49, "check_for_arrow_colliding_with_computers")
label(0x4a8c, "done_updating_computers")
label(0x4a9b, "check_for_arrow_colliding_with_enemies")
label(0x4aa0, "check_enemies_state_loop")
comment(0x4ac3, "enemy hit")
label(0x4af3, "check_next_enemy_state")
label(0x4afa, "finished_updating")
label(0x4a50, "computer_loop")
expr(0x4a72, "current_room_cache + 1")
comment(0x4a7d, "add 50 to score")
label(0x4a87, "next_computer2")
comment(0x4aa7, "enemy sprite number", True)
comment(0x4aca, "enemy sprite number", True)
sublabel(0x4aff, "check_return_key")
label(0x4b09, "check_for_doors_loop")
comment(0x4b14, "check if there is a door")
comment(0x4b22, "door found, check we have a key for the door")
comment(0x4b2f, "found key for the door, remove key and open door")
label(0x4b3e, "next_door")
comment(0x4b43, "ALWAYS branch", True)
blank(0x4b45)
label(0x4b45, "update_key_count")
label(0x4b65, "copy_cache_back_to_room_definition")
label(0x4b81, "skip_reset_door_animation")
label(0x4b83, "copy_room_definition_to_cache_loop")
label(0x4b8b, "plot_updated_number")
sublabel(0x4b93, "start_new_room")
label(0x4bb2, "skip_falling")
label(0x4bbe, "main_loop")
sublabel(0x4bee, "change_room")
label(0x4bec, "no_teleport_destination_found")
label(0x4bf3, "copy_current_room_cache_back_to_definition_loop")
label(0x4bfe, "find_new_room_loop")
label(0x4c0a, "next_room")
label(0x4c11, "found_closed_door")
comment(0x4c14, "new room index or 255", True)
comment(0x4c1b, "teleport to new room")
label(0x4c36, "skip1")
label(0x4c40, "skip2")
label(0x4c59, "room_ready")
sublabel(0x4c5c, "is_closed_door_near_player", "returns with carry clear if a closed door is near the player")
comment(0x4c5f, "check type of door (vertical or horizontal)", True)
label(0x4c71, "is_horizontal_door_open")
label(0x4c7d, "check_vertical_door")
label(0x4c8b, "is_vertical_door_open")
sublabel(0x4c98, "get_teleport_destination")

comment(0x4c95, "found door")
label(0x4c96, "no_door_found")
label(0x4cac, "find_teleport_info_loop")

expr(0x4c67, "current_room_cache + 1")
label(0x4cb1, "teleport_info_found")
sublabel(0x4cb3, "entry_point", "the program starts executing here")
entry(0x4cb3)
expr(0x4cbd, "<event_routine")
expr(0x4cbf, ">event_routine")
label(0x4cda, "title_and_game_loop")
sublabel(0x4d01, "reset_rooms_and_goto_title")
label(0x4d07, "reset_music_rooms_and_goto_title")
label(0x4d0d, "attract_loop")
blank(0x4d20)
sublabel(0x4e17, "press_space")
label(0x4e35, "wait_for_space_loop")
label(0x4e4e, "space_pressed")
sublabel(0x4e55, "wait_for_key")
label(0x4e70, "wait_for_key_loop")
sublabel(0x4e78, "check_for_key")
label(0x4e81, "pull_and_reset")
sublabel(0x4e86, "show_title_and_play_game")
label(0x4ee9, "end_of_game")
sublabel(0x4f4a, "game_completed")
label(0x4f51, "play_completion_sounds_loop")
label(0x4f63, "wait_for_sounds_to_finish_loop")

label(0x4fd2, "destroyed_computer")
comment(0x5004, "add 5000 to score")
sublabel(0x500b, "update_notes")
label(0x5020, "play_next_note")
sublabel(0x5032, "get_channel_1_bytes_free")
sublabel(0x503b, "reset_rooms")
label(0x503f, "reset_rooms_loop")
label(0x504e, "reset_room_loop")
label(0x505c, "skip_reset_item")
label(0x5063, "goto_next_room")
comment(0x5063, "reset section", True)
comment(0x5066, "reset section", True)
comment(0x5069, "reset section", True)
expr(0x5071, "room_count")
label(0x5075, "reset_next_section")
label(0x5076, "reset_next_section_loop")
sublabel(0x5084, "set_colour_one_white")
sublabel(0x508e, "set_colour_one_black")
sublabel(0x5098, "reset_current_text_colours")
sublabel(0x50a3, "set_inverse_colours")
sublabel(0x50ae, "one_time_init")
label(0x50b2, "copy_highscores_loop")
label(0x50b4, "copy_highscores_source_addr_high")
label(0x50b5, "opcode11")
label(0x50b7, "copy_highscores_dest_addr_high")
expr(0x50b3, "initial_highscore_table - $70")
expr(0x50b6, "highscore_table_names - $70")
label(0x50e8, "envelope1")
label(0x50f6, "envelope2")
label(0x5104, "envelope3")
label(0x5112, "envelope4")
byte(0x5120, 0x519d-0x5120)
label(0x5120, "music_pitch_table")
sublabel(0x519d, "event_routine", "event routine for updating music")
entry(0x519d)
label(0x51c0, "play_silence")
label(0x51c2, "play_note")
label(0x51c8, "reset_music")
comment(0x51cb, "author's comment (unused)")
sublabel(0x522a, "no_highscore")
label(0x5274, "no_highscore_local")
sublabel(0x5277, "update_highscores")
label(0x5283, "make_room_for_new_highscore")
expr(0x5294, "highscore_table_names + 25")
label(0x5290, "copy_highscore_name_loop")
label(0x52a3, "copy_score_loop")
expr(0x52a7, "highscore_table_scores - 7")
expr(0x52aa, "score_digits_0 - 1")
label(0x52b2, "next_highscore")
label(0x52c9, "made_space_in_highscore_table")
comment(0x5324, "show cursor and start to position the cursor")
comment(0x533b, "finish positioning the cursor by setting the Y coordinate", True)
comment(0x533e, "input name routine")
label(0x534e, "input_name_loop")
comment(0x5353, "check for ESCAPE key")
comment(0x5357, "hide cursor")
label(0x5357, "return_key_pressed")
label(0x5367, "input_name_key_pressed")
comment(0x536d, "ignore CTRL codes", True)
comment(0x5371, "if DELETE pressed, branch", True)
comment(0x5373, "ignore codes above DELETE", True)
comment(0x5388, "ALWAYS branch", True)
blank(0x538a)
label(0x538a, "delete_pressed")
comment(0x538c, "if no characters to delete then branch", True)
expr(0x5397, "highscore_table_names - 1")
sublabel(0x53a0, "compare_scores")
label(0x53a4, "compare_scores_loop")
sublabel(0x53b2, "show_highscore_table")
label(0x53c4, "show_highscores_loop")
label(0x53cd, "skip_invert_colours")
label(0x53dc, "skip_leading_space")
label(0x53e7, "write_highscore_name_loop")
label(0x53fc, "write_highscore_loop")

string(0x5417, 25)
string(0x5417 + 1*25, 25)
string(0x5417 + 2*25, 25)
string(0x5417 + 3*25, 25)
string(0x5417 + 4*25, 25)
string(0x5417 + 5*25, 25)
string(0x5417 + 6*25, 25)
string(0x5417 + 7*25, 25)
string(0x5417 + 8*25, 25)
string(0x5417 + 9*25, 25)
string(0x5417 + 10*25, 7)
string(0x5417 + 10*25 + 1*7, 7)
string(0x5417 + 10*25 + 2*7, 7)
string(0x5417 + 10*25 + 3*7, 7)
string(0x5417 + 10*25 + 4*7, 7)
string(0x5417 + 10*25 + 5*7, 7)
string(0x5417 + 10*25 + 6*7, 7)
string(0x5417 + 10*25 + 7*7, 7)
string(0x5417 + 10*25 + 8*7, 7)
string(0x5417 + 10*25 + 9*7, 7)
sublabel(0x5417, "initial_highscore_table", "High score table")
comment(0x5511, "highscores")
label(0x5800, "address_to_overwrite")
label(0x58d0, "energy_bar_screen_address")
label(0x5a10, "ammo_bar_screen_address")
label(0x5b50, "computer_bar_screen_address")

expr(0x3db7, "current_room_cache + 1")
expr(0x4654, "current_room_cache + 1")
expr(0x4761, "current_room_cache + 1")
expr(0x47cc, "current_room_cache + 1")
expr(0x4a20, "current_room_cache + 1")
expr(0x4a39, "current_room_cache + 1")
expr(0x4a59, "current_room_cache + 1")
expr(0x4a67, "current_room_cache + 1")
expr(0x4c8f, "current_room_cache + 1")
expr(0x4657, "current_room_cache + 2")
expr(0x476f, "current_room_cache + 2")
expr(0x47d6, "current_room_cache + 2")
expr(0x4a2a, "current_room_cache + 2")
expr(0x4a3c, "current_room_cache + 2")
expr(0x4a63, "current_room_cache + 2")
expr(0x4a75, "current_room_cache + 2")
expr(0x4c75, "current_room_cache + 2")
expr(0x4c81, "current_room_cache + 2")
expr(0x4b60, "current_room_cache + 3")
expr(0x4c12, "current_room_cache + 3")
expr(0x4b59, "current_room_cache + 4")
expr(0x4c15, "current_room_cache + 4")

# **************************************************************************************
stringhi(0x2193, include_terminator_fn)
stringhi(0x21d6, include_terminator_fn)
stringhi(0x2253, include_terminator_fn)
stringhi(0x22c5, include_terminator_fn)
stringhi(0x230f, include_terminator_fn)
stringhi(0x2335, include_terminator_fn)
stringhi(0x23d1, include_terminator_fn)
stringhi(0x2478, include_terminator_fn)
stringhi(0x2505, include_terminator_fn)
stringhi(0x258a, include_terminator_fn)
stringhi(0x260e, include_terminator_fn)
stringhi(0x271b, include_terminator_fn)
stringhi(0x2784, include_terminator_fn)
stringhi(0x27f6, include_terminator_fn)
stringhi(0x285c, include_terminator_fn)
stringhi(0x28e2, include_terminator_fn)
stringhi(0x2974, include_terminator_fn)
stringhi(0x29e3, include_terminator_fn)
stringhi(0x2ab9, include_terminator_fn)
stringhi(0x2c82, include_terminator_fn)
stringhi(0x2d7c, include_terminator_fn)
stringhi(0x2e0e, include_terminator_fn)
stringhi(0x314d, include_terminator_fn)
stringhi(0x31f1, include_terminator_fn)
stringhi(0x3276, include_terminator_fn)
stringhi(0x32f9, include_terminator_fn)
stringhi(0x367d, include_terminator_fn)
stringhi(0x377d, include_terminator_fn)
stringhi(0x38db, include_terminator_fn)
stringhi(0x393f, include_terminator_fn)
stringhi(0x3a1c, include_terminator_fn)
stringhi(0x3ab6, include_terminator_fn)
stringhi(0x3b0f, include_terminator_fn)
stringhi(0x3b65, include_terminator_fn)
string(0x3eb5)
string(0x3ea5)
string(0x3eab)
string(0x3eb8)

inkey_expr(0x401e)
inkey_expr(0x4029)
inkey_expr(0x4035)
inkey_expr(0x404d)
inkey_expr(0x483a)
inkey_expr(0x4844)
inkey_expr(0x484e)
inkey_expr(0x485f)
inkey_expr(0x4b00)
inkey_expr(0x4e3c)
inkey_expr(0x4e43)

# Define key constants
for key in found_keys:
    constant(key, acorn.inkey_enum[key])

go()

#print("free_total = $5800 - *")
