# Disassembler

from commands import *
import acorn
import re

config.set_label_references(False)
config.set_hex_dump(True)
#config.set_bytes_as_ascii(False)
config.set_show_autogenerated_labels(False)
config.set_show_cpu_state(False)
config.set_show_char_literals(False)
config.set_show_all_labels(False)
config.set_inline_comment_column(51)

load(0x8000, "lisp406.orig", "6502")
entry(0x8000, "entry_point")

acorn.bbc()

print(""";
; Acornsoft Lisp v4.06
;
; Reassembled by TobyLobster in 2023
;
; Made by disassembling the LISP406 binary with py8dis
; then adding original label names and comments.
;
; See https://stardot.org.uk/forums/viewtopic.php?f=2&t=23053
;
""")

labels = """
LISPST  8000
LISVAL  8000
ROMHDR  8000
TITLE   8009
VERSN   800e
CPYOFF  8012
TUBOFF  8038    ; Tube load addr
; ******************************
; Initialisation routine
; ******************************
INITUR  803c    ;Satisfactory?
CRYON   8041
        8045    ;Find out if in tube
COLD    8051    ;Find PAGE
        805D    ;Put on page boundary
PBOUND  8060
; ******************************
; Now copy down into RAM
; ******************************
        8068
; ******************************
; New initialisation routines
; ******************************
        807C
        807E    ;Memory OK
        8083+3  ;Fudge first reads
LOOP5   808E+3
        8099+3  ;No more to do if in I/O
; **** Copy to HILISP
INTUBE  80a1+3
; **** Change addresses
        80b6+3
; **** Alter vectors for tube
        80c3+3
LOOP3   80d1
        80d8+3  ; Next vector
        80e7+3  ; Prevent warm start offer
; Do a *GO WRMCHK (via HILISP)
        80ec+3
; General copy routine
COPY    8100
LOOP1   8102
; Address change routine
CHADD   8111
LOOP2   8118
CHRTS   8133
; ******************************
; Claim as service
; ******************************
INITSE  8134    ;Reasonable?
        8135+3  ; Help?
HELP    813D
        8141    ; Mustn't corrupt zero page
OKCALL  8153
        817D+3  ; Is there a tube?
        8181+3  ; If so don't flag
STLISP  818B
        818C+3  ; Start up LISP
NOTLSP  8192
; ******************************
; These are LISP's tables
; ******************************
; **** The text messages
TEXT    8198
VALTXT  81A5
NILTXT  81B1
DOTTXT  81B4
INSTXT  81B7
GCTXT   81CB
COLTXT  81D2
FRTXT   81E4
SUBTXT  81F0
ERRTXT  81F5
ARGTXT  8203
WRMTXT  820A
HLPTXT  8226
; **** Command lines
GOSTR   8231
LISTR   8239
; **** Readline control block
INCB    823E
        823D+3  ; Max line length
; **** Terminators
TERMS   8243
; **** CAR/CDR table
CXXXR   824B
; **** Table of CHARS lengths
LENTAB  826B
; **** Untraceable errors
CATTAB  8270
; **** Zero time
TIMZER  8276
; ******************************
; Routine to give optionsl warm
; start (ie OBLIST retained)
; ******************************
WRMCHK  827B
        827F+3  ; Offer warm start
NOTWRM  8285
        8287+3  ; We're in tube and
        8289+3  ; it's first time through
COLD1   8292
WARM    8295
; **** Reload from ROM
REBOOT  82B4
; ******************************
; This is the main LISP
; supervisor loop which is
; entered when LISP is called.
; ******************************
SUPER   82C6    ; Reset stack
        82CB+3  ; Reset hardware stack
        82CE+3  ; Check mode flag
        82D3+3  ;  Change mode
EVPR    82D9
        82D8+3  ; Evaluate:
        82db+3  ; Read expression
        82de+3  ; Evaluate it
        82e1+3  ; Value is:
        82e6+3  ; and print it
        82e9+3  ; Repeat ad infinitum
; ******************************
; Here are some condition
; routines taking advantage
; of POP
; ******************************
; **** ATOM
ATOM    82EF    ; Is ARGA atom?
        82EE+3  ; NIL => yes
        82F2+3  ; check bit 7
; **** EQ
EQ      82FB    ; ARGA = ARGB?
        82FA+3  ; ARGB NIL => ARGA NIL
        82FE+3  ; But they are numeric
EQUATE  8309    ; Fudge for nums
        830A+3  ; Both must be nums
        8315+3  ; Same length?
EQUINE  831E    ; Compare value
; **** NULL
NULL    8329    ; Is ARGA NIL?
NO      832D    ; Returns NIL
YES     8331    ; Returns T
POPA    8338
; ******************************
; POP is one of the two LISP
; stack handling routines. It
; restores old binding values
; and WSA, WSB and WSC from the
; stack and POP the stack. ARG
; is unchanged.
; ******************************
POP     833A    ; Get binding size
        833b+3  ; No bindings to do
POPPLE  8341
        8340+3  ; Get atom
        8348+3  ; Get old value
        834A+3  ; into A,X
        834f+3  ; Save Y
        8351+3  ; Put value back
        8353+3  ; into atom value
        8355+3  ; cell
        8359+3  ; Fetch Y back
        835B+3  ; More bindings?
        835F+3  ; Set stack pointer
        8360+3  ; to bottom of work-
        8362+3  ; Space area as if
        8364+3  ; there were no binds
NOBOUN  836B    ; Now Y = 1
        836B+3  ; Index for top space
        836D+3  ; Push return addr
MORSP   8378    ; Copy back TVS
        8377+3  ; WSA, WSB and WSC
        837D+3  ; Add TVSEXT + 2 to stack
        837E+3  ; pointer to POP the stack
TVF     838C
TVG     8390

; ******************************
; STACK stores:
;
;    Extent of TVS, WSA, WSB,
;    WSC, ARG and return addr
;     on the LISP stack
; ******************************
STACK   8393
EXTRAM  839C
SQUAT   83AD
STIR    83B2    ; None found
SROOM   83BC
        83C5+3  ; Store ARG
        83D0+3  ; Store return addr
PILE    83DC

; ******************************
; BIND adds a 'new value' to the
; bottom of the stack:
;   WSD     - Pointer to atom
;   TVS + X - New value
; ******************************
BIND    83EA
SQUASH  8400

BEAR    8402+3  ; None found
XROOM   840C+3
        8414+3  ; Carry is set
        8420+3  ; Old value and atom
        8423+3  ; on stack
        842C+3  ; Bound var size
        8430+3  ; New value in atom
; ******************************
; Here is the space allocator
; routine. If allocates up to
; 256 bytes of initialized store
; ******************************
ALNUM   843A+3
ALVEC   843C+3
ALCHAR  8440+3
ALFSBR  8444+3
ALSUBR  844A+3
ALPAIR  8450+3
        8452+3  ; Pointer space
SPACE   8454+3
SPACEB  8456+3
SQUID   8470+3
ALLO    8475+3  ; None found
ROOM    847F+3
        8496+3  ; UNDEFINED
OBSCUR  84A0+3
PINS    84A7+3
        84AB+3  ; Initial NIL point

; ******************************
; Here are the initialisation
; routines
; ******************************
INIT    84B2+3
        84B4+3  ; Error handling
        84BC+3  ; Find end of memory
; **** Set up various values
        84C3+3  ; Messages except GC
        84C9+3  ; Output to screen
        84CB+3  ; Zero collections
        84CF+3  ; Zero error count
        84D3+3  ; Clear TVS etc.
ZLP     84D5+3
        84DA+3  ; Initially no args
        84DE+3  ; Zero GC time
        84E1+3  ; Zero time
        84e4+3  ; Set up Escape check
        84f6+3  ; Enter supervisor
; **** Message handler
MESSAH  84F9+3
MESSAI  84FB+3
MESSAG  84FD+3  ; Print message
        8501+3  ; Remove flag bit
        8507+3  ; Retrieve flag
        8508+3  ; Bit 7 not set
OUT     850B+3  ; to screen?
OUTSCR  8512+3
CROUT   8516+3
NCR     8518+3  ; Print the char
; ******************************
; Main evaluation routine
;
;    arg           -> ARG
;    NIL           -> NIL
;    number, entry -> same
;    char          -> same
;    list          -> eval fn
;
; ******************************
NXEVAL  851B+3
FSARG   851F+3  ; No more args
NXEVAM  8533+3
; **** Main evaluator
EVALU   8536+3  ; Main entry
        853B+3  ; Escape
KBCHK   8544+3
EVAL1   8553+3
        8555+3  ; NIL?
        8559+3  ; Check type
        8564+3  ; Get value cell
EVLIST  856C+3
FUNERR  8594+3  ; Can't make function
EVARTS  85A8+3
FUN     85A9+3
        85B1+3  ; Char atom
        85B5+3  ; Lambda?
ENT     85C7+3  ; Probably entry
        85CC+3  ; Keep fn safe
        85DE+3  ; Oops a number!
MORAG   85E0+3
        85E9+3  ; Args eval in TVS
ISSUBR  85F5+3
INSUBR  85F9+3
NARGER  8608+3  ; Wrong # of arguments
ISFSBR  8624+3
        862F+3  ; List in WSD
DEFLST  8634+3
PLOP    863D+3  ; Default needed
SKIP    864C+3
GOSUB   8656+3  ; Go and do it!
        8661+3  ; End of subrs

; ******************************
; Time for some lambda
; ******************************
LAMOK   8664+3
        866A+3  ; No parms or body
        867E+3  ; Parm list
        8688+3  ; Body in WSC
        8691+3  ; NIL parms?
AVX     8698+3
        869E+3  ; NB spelling!
LAMERR  86A0+3  ; Syntax error
ISFXP1  86B0+3
MORFAG  86B3+3
        86B6+3  ; Spread args for expr
GODARG  86BF+3
ISEXPR  86CB+3
RADON   86CF+3
XENON   86D1+3
        86DF+3  ; Enough args?
        86EF+3  ; The default value?
NOD     86F5+3
        86F9+3  ; Get the atom bind
        8707+3  ; Must be char atom
DOBIND  8709+3
GADARG  870E+3  ; Bind takes atom
        8711+3  ; in WSD and value in TVS + X
ISFXPR  872B+3
XLAMB   873A+3
XLAM    873C+3
XLAMD   8742+3
XLAMC   874A+3
SYNNED  8753+3
EVPOP   8766+3
; **** Get a character
GTCHAR  8769+3
        876D+3  ; From file
RENEW   8776+3
REOLD   8779+3
KEYCH   877D+3  ; From screen
        8781+3  ; => New line
; **** Read a line
        8785+3  ; Prompt masked?
PRDEPT  878C+3
READON  8796+3
        879C+3  ; Read line
RDCHER  87A1+3  ; Escape
OKLINE  87AA+3  ; Zero => newline
NNL     87AE+3  ; Fetch char
        87B1+3  ; RESTORE X
        87B4+3  ; Get char form buffer
        87BD+3  ; New line next time
XYZ     87BF+3
RSREAD  87C0+3
        87C8+3  ; Flag for new line
; **** READ
READ    87CC+3
        87CE+3  ; Flag for rubbish
NXCHAR  87D3+3
RPT     87D6+3
        87E6+3  ; It's a quote
ODDAT   87EF+3  ; Entry for atoms
        87F2+3  ; Get list cell for it
MORODD  8815+3
RDLJMP  8820+3
PARQU   8823+3
        8827+3  ; Some sort of atom
        8829+3  ; Escape
        882D+3  ; Ordinary char atom
QUEER   8834+3  ; Syntax error
SPCATM  8842+3  ; Escaped char
NORMAL  8845+3  ; Fetch chars
; ******************************
; Here check if numeric. Find
; or set up char atom.
; ******************************
        885A+3
TRYCHR  8861+3
AMADE   8864+3
; *** Read a list
RDLIST  886F+3
DOTTY   8881+3  ; Dot syntax
LON     888E+3
        8898+3  ; First element?
        88A6+3  ; Always taken
NEWLST  88A8+3
ALLIST  88AC+3
        88C2+3  ; Dotted pair at end
        88D3+3  ; Shouldn't return
        88D6+3  ; Dot syntax error
READX   88D9+3
; **** Look for terminators
TERMQ   88E2+3
TERRTS  88EA+3
; **** Next arg from WSA's list
NXTARG  88EB+3
ARGERR  88EF+3
NXTARH  88F2+3
LCHAR   890E+3
PUTBCK  891D+3
        8920+3  ; Reverse file pointer
        8926+3  ; Fudge CR into buffer
MIDBUF  892D+3
EXFILE  8932+3  ; COS version
LISTND  893C+3
; **** Make number in POINT
MAKNUM  894B+3  ; Text from IMBUF


# Page 2

PLUSS   8963+3
        896B+3  ; Not a digit
        8971+3  ; *10 now
        8976+3  ; That's * 2
        8978+3  ; Overflow
YIA     897F+3
YIB     8984+3
YIC     898A+3
YID     8991+3
        89A9+3  ; Any more digits?
        89AF+3  ; Reverse sign if -ve
MKOVFL  89BA+3
        89BB+3  ; Not number
PLUSSS  89BC+3
NTOVFL  89C0+3
MKRTS   89CF+3
NEXTAD  89D0+3
NEXTAA  89D6+3
NAAB    89DC+3

; ******************************
; MATCH tries to find a string
; to match the string in IMBUF.
; If it cannot it makes up a
; new atom.
; ******************************
LETTER  89E5+3
MATCH   89EC+3
LONGER  89FA+3  ; String too long
CHKCLL  8A0C+3
CHKCLM  8A0E+3
MCOP    8A29+3
        8A2A+3  ; Chars the same?
TESTY   8A32+3
        8A36+3  ; NIL?
BOX     8A45+3
        8A47+3  ; It's found
NXTCLL  8A48+3
MCAP    8A63+3
TOSTIG  8A6A+3
        8A6C+3  ; New cell made
NXCELL  8A6D+3  ; Given pointer
        8A6F+3  ; in CELL, finds next
        8A71+3  ; CELL
SIX     8A7E+3
GOT     8A80+3
HCOK    8A88+3
FILGB   8A91+3
FILGC   8A99+3
ZIP     8aa0+3
IPLINE  8AA3+3
MOLIN   8AA8+3
        8AB3+3  ; Don't want CR at end.
; ******************************
; Here there be the point
; routines of various types:
; ******************************
; **** Intercept return addr
GETSSP  8AB9+3  ; Find SSP ret addr
STINC   8ACE+3
; **** WRITE
WRIT    8AD4+3  ; Locate ret addr
WRITGO  8ae6+3
; **** WRITE0
WRTTZ   8AEF+3
; **** Error entry
PRINTE  8AFB+3
; **** PRINT
PRINT   8B01+3  ; Put in esc char
; **** PRIN
PRINZ   8B05+3
; **** PRINTC
PRINTC  8B09+3
PRINT1  8B0B+3
PRINGO  8B20+3
; **** PRINC
PRINC   8B27+3
PRIN1   8B29+3
PRINOK  8B2C+3
GENWRI  8B32+3
        8B34+3  ; NO ARGS?
PRON    8B38+3
NILFR   8B53+3
; **** Get file handle
FILG    8B56+3
FILGER  8B69+3
SAVAR   8B6C+3  ; Saves ARG in WEB
CCPR    8B75+3  ; Escape
; **** Just prints ARG
PRINA   8B7E+3
PRINB   8B83+3  ; Check for escape
        8B8A+3  ; NIL?
        8B8E+3  ; 'NIL'
; **** Main printer
NPN     8B91+3
        8B95+3  ; Atom or list?
        8B9C+3  ; Since recursive
; **** Print list
PLIST   8BA9+3
NASTY   8BAE+3
RPP     8BCE+3
BADAT   8BD6+3  ; Unknown atom type
; **** Print atom
PATOM   8BE6+3
PATOMB  8BEA+3  ; If char atom
        8BEE+3  ; If number atom
        8BF2+3  ; If subr atom
        8BF8+3  ; Fsubr
HASH    8BFD+3
        8C06+3  ; Print entry addr.
; *** Char atoms
OKP     8c10+3
FOOT    8C17+3
FTOUT   8c1e+3
ESCFT   8C24+3
        8C2b+3  ; Save character
        8C2c+3  ; Escape in char
INCHP   8C35+3
; **** Print a number
PNUM    8C3B+3
; **** Actual number printer
PINT    8C54+3
CLDIV   8C58+3
NOMSIN  8c67+3
MDIGP   8C7E+3
NDP     8c85+3
; **** Finds end of char atom
GENDS   8C89+3
        8C8B+3  ; Char atom
        8C8E+3  ; AA +1 TO AB -1
; *** EOF
EOF     8CA6+3
        8CA9+3  ; Get file handle
        8CAE+3  ; Put pointer into ACL
        8CB5+3  ; File extent
EOFCP   8CBE+3
EOFNO   8CCA+3
; **** CLOSE
CLOS    8CCD+3
        8CD5+3  ; Close file (A lost)
; ******************************
; File with CAR, CDR and COND
; functions.  Includes PROGN,
; PROGNA and POINTN as useful
; entry points.
; ******************************
PARERR  8CDD+3  ; COND syntax
; **** COND
COND    8CEB+3
REMAIN  8CF2+3
        8CFB+3  ; Split:
        8CFD+3  ; Condition - ARG
        8CFF+3  ; Actions   - WSB
        8D01+3  ; Rest      - WSA
        8D14+3  ; Condition NIL?
        8D16+3  ; Next condition duo
MTODO   8D22+3
PROGN   8D25+3
PRGEND  8D29+3
; **** UNTIL
UNTIL   8D2C+3
; **** WHILE
WHILE   8D35+3
WILL    8D3E+3
WILLY   8D41+3
; **** QUOTE
QUO     8D4A+3
; ******************************
; Now the CAR - CDR complex
; ******************************
PERR    8D50+3  ; Atomic arg
CDDDR   8D62+3
CADDR   8D66+3
CDADR   8D6A+3
CAADR   8D6E+3
CDDAR   8D72+3
CDDR    8D76+3
CADAR   8D7A+3
CADR    8D7E+3
CDAAR   8D82+3
CDAR    8D86+3
CDR     8D8A+3
CAAAR   8D8E+3
CAAR    8D92+3
CAR     8D96+3
CXR     8D98+3
CXLP    8DA0+3
; **** ERROR
ERRORL  8DC1+3
LISPER  8DC4+3
; **** AND
_AND    8DD5+3
ANDON   8DDC+3
; **** OR
OR      8DE6+3
ORON    8DED+3
; **** LOOOP
LOOP    8DF7+3
RESTAR  8DFF+3
RIPON   8E07+3
; ******************************
; Extra LISP entry points
; ******************************
; **** CONS
CONS    8E1B+3
CONSLP  8E20+3
; **** SET
SET     8E31+3
; **** SETQ
SETQ    8E37+3
DOSET   8E3A+3
        8E4A+3  ; Alter value cell
SETERR  8E58+3  ; SET non-atomic
; **** LIST
LIST    8E69+3
LL      8E73+3
NOLLY   8E9D+3
; **** VDU
VDU     8EA0+3
MVDU    8EA5+3
        8EAF+3  ; LS byte of arg
        8EBA+3  ; Result is ARG
; ******************************
; Conditionals on numeric atoms
; ******************************
; **** CHARP
CHARP   8EBD+3
YESNIL  8EC7+3
; **** SUBRP
SUBRP   8ECA+3
; **** FSUBRP
FSUBRP  8ECE+3
; **** LISTP
LISTP   8ED2+3
; **** NUMBERP
NUMP    8ED6+3
TYPE    8ED8+3
NNO     8EE5+3
; **** ZEROP
ZEROP   8EE8+3
; **** ONEP
ONEP    8EEC+3
TSN     8EEE+3
        8EF0+3  ; CHECK IT IS NUM.
; **** MINUSP
MINUSP  8F07+3
; ******************************
; Set up DCB for file I/O
; ******************************
SETDCB  8F1C+3  ; Pointer to name
        8F1F+3  ; m/c higher order addr
        8F24+8  ; Load & save addr
        8F41+8  ; End addr
        8F53+8  ; DCB complete
; **** LOAD
LOAD    8F54+8
        8F57+8  ; Load operation
INUREL  8F60+8  ; Set up base
        8F6C+8  ; Re-start LISP
; **** DUMP
DUMP    8F6F+8  ; GC
        8F72+8  ; Set up before relat
        8F75+8  ; Make relocatable
        8F78+8  ; Save
CHARQ   8F84+8
CHARQR  8F88+8
FILERR  8F8F+8  ; Not char atom
ATOA    8FA9+8
ANUM    8FB2+8
; **** CALL
CALL    8FC1+8
        8FC6+8  ; Set up return
        8FC7+8  ; address
        8FCA+8  ; Get A
        8FCC+8  ; and call
; **** PEEK
PEEK    8FCF+8
BACALL  8FD4+8
BECALM  8FD6+8
; **** POKE
POKE    8FDF+8
; OBLIST
OBLIST  8FF1+8  ; Only want good
        8FF4+8  ; cells
BOOM    8FF8+8
        8FFF+8  ; Value UNDEFINED?
NEXOS   902D+8
USEFUL  9035+8  ; Checks for
        9037+8  ; string rather than
        9039+8  ; OBLIST atoms
        9045+8  ; NIL P-list
USABLE  9049+8
; **** Make DOS name
MKNAM   904A+8  ; FOR DOS
        9059+8  ; Get name length
        905C+8  ; Terminator
MORLET  905E+8
        9068+8  ; Always taken
; **** *
STAR    906A+8
SMALLP  9077+8
MORLEZ  907A+8
STARRY  9086+8
; **** OPEN
OPE     9090+8
        9099+8  ; OPEN FOR READ
WOPEN   909E+8  ; OPEN FOR WRITE
ROPEN   90A0+8
        90B3+8  ; RESULT IN A
FNERR   90B6+8  ; File not found
; **** Unrelativise
UNREL   90C7+8
        90C9+8  ; Get old IMBOT value from UNDEFINED
        90CF+8  ; Relativisation constant
        90D4+8  ; Set up slave
        90DA+8  ; Length of IMAGE
        90E3+8  ; Real end of IMAGE
        90E5+8  ; Get first item
NEXTU   90E9+8
        90EB+8  ; Sort out type
        90FD+8  ; Must be dotted pair
        9107+8  ; Length
URN     910B+8  ; Number
        910D+8  ; No alteration
URC     910F+8  ; Character
URS     9119+8
URF     9119+8  ; Subr/Fsubr
TWOADD  9120+8
ALTADU  9127+8  ; Adjust addr
        9129+8  ; NIL - needn't alter
NOTU    9131+8
NXITU   9132+8
NXIT    9138+8  ; Step to next item
        9143+8  ; End of image
NOTOK   9151+8
        9152+8  ; End reached
OKOUT   9153+8
        9154+8  ; End not reached
; **** RELAT (somewhat reduced!)
RELAT   9155+8
        9157+8  ; Reset base
; **** RECLAIM
RECLAM  916C+8  ; Force G.C.
; **** QUOTIENT
QUOT    9172+8
; **** REMAINDER
REM     9176+8
DODO    9178+8  ; Save index for
        917A+8  ; returned number
        917F+8  ; Zero initial rem.
        9183+8  ; Have cell ready
        9188+8  ; Move ARG"s" to
        918A+8  ; workspace
        9193+8  ; Divide by zero!
        919D+8  ; Divide
        91A0+8  ; Check sign
        91A4+8  ; Change ACL sign
POSV    91A9+8  ; RETREIVE RESULT
        91AF+8  ; Put in new cell
        91B6+8  ; return POINT
; **** DIFFERENCE
DIFF    91B9+8
; **** MINUS
MINUS   91D1+8
FINONE  91E5+8
; **** SUB1
SUBA    91EA+8
; ADD1
ADDA    91F5+8
WONE    91FE+8
OVFERR  920B+8  ; Overflow
; **** PLUS
PLUS    9221+8
MPLUS   9232+8
PEX     924A+8
; **** TIMES
TIMES   9255+8
MTIMES  9263+8
POSITV  9294+8
TREX    9296+8
ACLRET  929C+8
; **** CHARS
CHARS   92AD+8
        92B4+8  ; List index
FIXTY   92C6+8
XGOOD   92C9+8
AGOT    92CC+8
GPLIST  92D8+8
; **** RPLACA
RPLACA  92E7+8
; **** RPLACD
RPLACD  92EB+8
PLAQ    92ed+8
PLAQER  9306+8  ; Wrong 1st arg
; **** LESSP
LESSP   931F+8
SWIP    9321+8
; **** GREATERP
GT      932C+8
BIGGER  9345+8
DFSGN   9348+8
SMALLR  934A+8
SOCK    934D+8
        9356+8  ; A-list search
SOCKA   9358+8  ; routine
ROCKON  935B+8
LKH     9366+8
LKG     936A+8
ALERR   938F+8  ; P-list error
; **** ASSOC
ASSOC   93A2+8
        93AC+8  ; Fudge arg order
        93B7+8  ; Save ret code as carry
        93C1+8  ; If SOCKA returned zero
HAUSE   93C9+8
; **** GET
GET     93CE+8
; **** PUT
PUT     93E4+8
INSERP  93FC+8
; **** REMPROP
REMPR   9442+8
FRUIT   9457+8
FRUT    9471+8
FRUTA   9474+8
HOUSE   947C+8
; **** Check all numeric args
ALLNUM  947F+8
MORIX   9485+8
COMPX   948D+8
NUER    9494+8  ; Non-numeric args
EVAL    94AB+8
; ******************************
; APPLY/MAP complex
; ******************************
APFUN   94B4+8
        94C2+8  ; It's a subr
APFERR  94C4+8
GEVIL   94D5+8  ; Expr?
        94F7+8  ; Parm list in WSB
        9505+8  ; Body in WSC
        950E+8  ; Fexpr?
GFRTS   9513+8
APERR   951C+8  ; APPLY list
; **** APPLY
APPLY   952E+8
APL     953D+8
        954E+8  ; Spread args into TVS
        9562+8  ; Always taken
APGO    9564+8
APGOB   9566+8
        956A+8  ; Expr entry
SUBAP   956D+8  ; Subr entry
MAPSTR  9570+8  ; Prelims for
        9573+8  ; MAP functions
MAPMOV  9575+8
MAPRTS  9589+8
NILMAP  958a+8
; **** MAP
MAP     958D+8
MAPON   9592+8
; *** MAPC
MAPCAR  959D+8
MAPCON  95B4+8
OLDMAP  95C9+8
; **** GETCHAR
GETCHA  95FD+8  ; File arg?
GETDIR  960C+8  ; Grab a char
; **** CHARACTER
ASCII   961A+8
POST    9621+8  ; Finds char atom
; **** ORDINAL
ORDINL  9627+8
EMPTYC  963A+8
CARAP   963D+8
CARAVA  9644+8
CARAFE  9660+8
MAPERR  9667+8  ; MAP args
CDRALL  967C+8
CDRAVA  9680+8
CDRAWL  969D+8
CDREND  96A1+8
; **** EXPLODE
EXPLOD  96A2+8
THUMP   96AC+8
BANG    96D9+8
IMPERR  96E0+8  ; No space
; **** IMPLODE
IMPLOD  96F6+8
SQUISH  96FD+8
NODNIL  970E+8
        9716+8  ; Not char err
ISCH    9719+8
SPLOT   9722+8
EMM     972B+8
WSBTST  973C+8
IMPRET  9744+8  ; Show string length
; **** MESSON
MESSON  974A+8
; **** MESSOFF
MESSOF  9758+8
; **** MODE
MODE    9768+8
        9770+8  ; Get mode
        9772+8  ; Mod 8
        9776+8  ; Flag bit
; **** Actually change mode
MODCHN  9783+8
        9788+8  ; Clear flag bit
        978E+8  ; M/c HO addr.
        9793+8  ; In 2nd processor?
        979A+8  ; Get new aretop
        979D+8  ; Room for OBLIST?
MODERR  97A9+8  ; No room
CHARE   97BD+8  ; New ARETOP
        97BF+8  ; Reset software stack
CHANGE  97C1+8  ; Change mode
; **** USR
USR     97CA+8
        97D1+8  ; Call addr
        97D8+8  ; Get carry
        97DA+8  ; And adjust flag
        97DD+8  ; Get A
        97E0+8  ; Get X
        97E3+8  ; Get Y
JUMPAD  97EE+8  ; Enter routine
OUTL    97F1+8  ; Build up result list
        97F5+8  ; Save status
        97F7+8  ; Restore A
        9800+8  ; NIL
        9802+8  ; Get status
        9804+8  ; status
        9808+8  ; Y
        980C+8  ; X
        9810+8  ; A
        9813+8  ; Return list
; **** Put A on list in WSA
BUILD1  9816+8
; **** Put A & X (msb) on WSA
BUILD2  9818+8  ; WSB has val
SETNUM  983C+8  ; Num atom in WSB
; **** SOUND
SOUND   9856+8
MORSOU  985D+8
ENTOSW  9879+8
; **** ENVELOPE
ENV     9883+8

#
#
# Page 3
#
#
MORENV  988A+8
        9892+8  ; Prepare index
; **** Get an argument
GTARG   98ad+8
; ******************************
;  Now the clock handling
; routines
; ******************************
RESET   98b7+8
        98bd+8  ; Value is T
; **** Zero the clock
STCLK   98C0+8  ; Write clock
ZERTIM  98C2+8
        98C9+8  ; Restore pointer
; **** Zero GC time
GCTIMZ  98ce+8
MGCTIM  98D2+8
; **** Read the clock
TIMER   98D8+8
        98DE+8  ; Read the clock
        98E1+8  ; Restore pointer
; **** TIME
TIME    98E6+8
; **** GCTIME
GCTIM   98EC+8
; **** Return a time
TIMPOP  98F0+8
; **** CLOCK
CLOCK   9909+8  ; Time in TIMEW
MCLK1   9910+8
        9911+8  ; Zero remainder
        9914+8  ; Zero divisor
        9917+8  ; Dividend
        9920+8  ; Throw away cs
        992D+8  ; Get the seconds
        9937+8  ; NIL
        9944+8  ; Get the minutes
        9952+8  ; Get the hours

; **** POINT
PVAL    995E+8
        9963+8  ; X lsb
        9968+8  ; Y msb
        996E+8  ; X lsb
        9973+8  ; Y msb
        998B+8  ; Point on screen
PEXIST  998E+8
; **** ADVAL
ADVAL   9997+8
        99AD+8  ; Make range +/-2^15
; **** INKEY (added 18/8/83 RMT)
INKEY   99BA+8
INKER   99E3+8
INKEY2  99ED+8  ; Scan keyboard
INKYES  99FF+8
; **** GENSYM (added 31/8/83 RMT)
GENSYM  9a02+8
NXDIGT  9a0a+8
NOCAR   9a15+8
        9a22+8  ; Look up Gxxxx
        9a29+8  ; Is it UNDEFINED ?
        9a37+8  ; No properties ?
; ******************************
; Useful Boolean routines
; ******************************
; **** BNOT
BNOT    9a3e+8
; **** BAND
BAND    9a56+8
MBAND   9a67+8
; **** BOR
BOR     9a86+8
MBOR    9A97+8

; ******************************
; Garbage collector file.
; ******************************
; **** Set CELL to image start
SETCEL  9Ab6+8
; **** Clear all G.C. flags
CLEARF  9AC0+8
RZ      9AC5+8
; ******************************
; Register a set of cells,
; starting from the one in GCA.
; ******************************
REGCDR  9AD1+8
REGPIN  9AD3+8
LIN     9Ae3+8
BOT     9ae9+8
REGIS1  9AEF+8
REGISU  9af1+8
REGRTS  9b03+8
REGIST  9B04+8  ; This code added by RMT
        9b06+8  ; 12/9/83 to prevent bug
        9b08+8  ; probably caused by ARG
        9b0a+8  ; being &FFxx
VIRGIN  9B0B+8
LINJ    9B16+8
        9b22+8  ; Always taken
STOCK   9B24+8
; **** Garbage Collector entry
RUBBSH  9B3E+8
        9b42+8  ; Mark memory invalid
        9b47+8  ; Start timing
        9b49+8  ; Zero timer
HGCA    9B5C+8
        9b64+8  ; Save I/O file handle
        9b65+8  ; 'G.C. no.'
        9b6c+8  ; Print no. of G.C.'s
NOMESA  9b78+8
        9b7d+8  ; Stack limit
COLLEC  9B81+8
        9b83+8  ; Register off WSA etc.
CREG    9B85+8
SREG    9B92+8
STRETH  9BA5+8  ; Register off stack
STUP    9BB1+8
STCOLL  9BB8+8
BOWDUN  9BBF+8
SPOCK   9BC8+8
        9bce+8  ; Avoid the return addr
STCOL   9BD0+8
CXH     9BD8+8
CXHB    9BDE+8
LOOKW   9BE6+8  ; Now off whole
        9be9+8  ; Set overflow
MORWS   9BED+8
        9bf7+8  ; Register if half
        9bf9+8  ; finished,
DOREG   9C02+8  ; or if char atom
NOREG   9C0F+8
        9c15+8  ; There's more
; ******************************
; Having registered the cells,
; now to move the memory about
;    First calculate the change
; in position of all the blocks
; ******************************
        9c17+8
ML      9C20+8
SETMIN  9C2D+8
        9c33+8  ; Top of static
DLOP    9C35+8
STFR    9C48+8
STUSE   9C70+8
SIXG    9C7E+8
ADDIN   9c80+8
NHCIQ   9c96+8
TADJ    9cA7+8
; ******************************
; Having calculated the
; dispacements, now to alter
; the pointers
; ******************************
ADJUSS  9CAF+8  ;Adjust stack
ASP     9cb7+8
NOLEAP  9cc5+8
LUCK    9cce+8
        9cd4+8  ;Adjust workspace
        9cf0+8  ; Revises pointer over
ADJUT   9cf2+8  ; whole of
LICE    9D05+8
NXADJ   9D08+8
; ******************************
; Now move the blocks about
; ******************************
        9D0D+8  ; AD has top of static
        9d0f+8  ; space
SAL     9d15+8
MOLE    9d27+8
ABGO    9d31+8
        9d38+8  ; PUT LENGTH IN GCA

; ******************************
; Fast move routine
; ******************************
        9d3e+8
MORMOV  9d46+8
BITMOV  9d55+8
        9d5e+8  ; If GCA is zero loop
FINMOV  9d6a+8
; ******************************
; Now to calculate the gain in
; cells etc.
; ******************************
CLUP    9d6d+8
CLUPB   9d77+8
        9d93+8  ; Save file handle
        9da7+8  ; ' Bytes collected '
        9dbe+8  ; ' Bytes free<CR>'
        9dc2+8  ; Restore file handle
NOMESC  9dc4+8
        9dca+8  ; Read timer
MORTIM  9dd2+8
AJCELL  9ded+8
        9df8+8  ; Bottom of top block
SPECS   9e0a+8
SPECTR  9e0c+8
ONW     9e15+8
ONX     9e1b+8
GCAON   9e22+8
SIXP    9e34+8
ADDOUT  9e39+8
        9e4e+8  ; Always taken
PAGDIQ  9e4f+8
PAGDIP  9e50+8
CHUG    9e5b+8
CHUGB   9e5d+8
NXPR    9e64+8
SPREG   9e6a+8  ; Stack register
NULBOW  9e7c+8
; ******************************
; The error handler
; The stack is "gently" taken
; down with diagnostic printout.
; ******************************
ERRORS  9e7f+8
; **** Main error entry
ERROR   9e7f+8  ; Ack escape
        9e84+8  ; Increment error count
        9e91+8  ; Save LEVEL
        9e97+8  ; Get errno.
; **** Traceback wanted?
        9e9d+8
NEXCAT  9e9f+8
        9ea3+8  ; Allow trackback
        9ea9+8  ; Match
        9ead+8  ; No traceback
TRCOK   9eaf+8
        9eb1+8  ; Reset stack
        9eb7+8  ; Page mode
        9ebc+8  ; Mask for LEVEL
        9ec0+8  ; Error # mask
        9ec6+8  ; "^Error number "
        9ecf+8  ; Print err no.
NERRA   9ed2+8
        9ed4+8  ; Err mess mask
        9ed8+8  ; Print err mess
NERRB   9edb+8  ; Top args mask
        9ee1+8  ; Print ARG
NERRC   9ee4+8
DWARF=NERRC-1
        9ee6+8  ; Pop return
        9ee8+8  ; stack completely
        9eec+8  ; Page mode off
        9ef1+8  ; Old LEVEL
        9ef3+8  ; Restart
; **** Collapse the stack
WINDER  9ef6+8
        9efa+8  ; Used bind count
        9efc+8  ; Get binding state
        9f01+8  ; Add work space
        9f05+8  ; To get ARG
        9f09+8  ; Put ARG in WSB
        9f0f+8  ; Check ret addr for
        9f11+8  ;  ERRORSET
        9f16+8  ; and low byte
        9f1a+8  ; Not ERRORSET
        9f1e+8  ; Remove ERRORSET
        9f20+8  ; stack entry
QZQ     9f28+8  ; Return err no.
        9f2e+8  ; Page mode off
        9f31+8  ; POP via ACLRET
SLIP    9f34+8
        9f36+8  ; Set up return for POP
        9f3d+8  ; Check trace print
        9f3f+8  ; is this second arg
        9f41+8  ; Skip rint
        9f43+8  ; Clear top arg flag
        9f49+8  ; Any bound vars?
; **** Do bound var pairs
        9f4d+8
ERBIN   9f4e+8  ; Get var name into
        9f50+8  ; ARG
        9f5a+8  ; NB. WSC +&01 is &00
        9f5f+8  ; Print var name
        9f67+8  ; Print a space
        9f6c+8  ; Get the value of the
        9f6e+8  ; variable into ARG
        9f78+8  ; Print it
        9f7b+8  ; Repeat if more
; **** Remove rest of stack
BINS    9f7f+8
NOPE    9f8a+8  ; And back to NERRC
ERCN    9f8d+8
ERCND   9f91+8
PSTRNG  9f9d+8  ; Print err mess
NXOUT   9fa1+8
PARG    9fae+8  ; Look for flag
        9fb3+8  ; Print ARG
        9fb5+8  ; 'Arg :'
ARGRTS  9fbb+8
; **** ERRORSET
ERRSET  9fbc+8
ELFIN   9fbf+8
STEVAL  9fd0+8  ; ELFIN on stack
; ******************************
; Useful arithmetic routines
; ******************************
; **** 16 bit multiply
MULPM   9fd9+8
        9fdc+8  ; Index for 16 bits
MUL     9fdc+8
MULB    9fde+8
MULC    9fe6+8
MULD    9fef+8
MULE    9ff1+8
; **** 16 bit divide
DIVPM   9ffa+8
DIV     9ffd+8
DIVB    9fff+8
DIVC    a019+8
; **** Negation routines
MDA     a01d+8
        a01f+8  ; Abs value of
        a021+8  ; AUXL with sign in
        a026+8  ; ls bit of SIGN
MDB     a028+8
MD      a02c+8
MDRTS   a039+8
; **** 40 bit divide
DIV40   a03a+8
DIV40B  a03c+8
MDIV1   a044+8
MDIV2   a04f+8
MDIV3   a05b+8
MDIV4   a06c+8
DIV40C  a078+8
LISPEN  a07f+8

unused1 a087

; ******************************
; This file holds the vectored
; core routines. These are
; held in 2 pages immediately
; preceding the image.
; ******************************
VECTAB  a400

unused2 a538

; Calculated expressions put at the end of the assembly so they resolve on the
; first pass which makes the asserts at the end of the file work.
HIWARM  = WRMCHK + HILISP - LISVAL
EVOFF   = TEXT   - TEXT
VALOFF  = VALTXT - TEXT
NILOFF  = NILTXT - TEXT
DOTOFF  = DOTTXT - TEXT
INSOFF  = INSTXT - TEXT
GCOFF   = GCTXT  - TEXT
COLOFF  = COLTXT - TEXT
FROFF   = FRTXT  - TEXT
SUBOFF  = SUBTXT - TEXT
ERROFF  = ERRTXT - TEXT
ARGOFF  = ARGTXT - TEXT
WRMOFF  = WRMTXT - TEXT
HLPOFF  = HLPTXT - TEXT

; ******************************
; The first LISP image file
; ******************************
IMAGE   a600
ZA      a602
CTRUE   a611
LAMBDA  a618
NIL     a624
QUOTE   a62d
ZB      a638
ZC      a642
ZD      a64d
ZE      a657
ZF      a661
ZG      a66a
ZH      a672
ZI      a67c
ZJ      a685
ZK      a68f
ZL      a699
ZM      a6a2
ZN      a6ac
ZO      a6b6
ZP      a6bc
ZQ      a6c2
ZR      a6c8
ZS      a6ce
ZT      a6d4
ZU      a6da
ZV      a6e0
ZW      a6e6
ZX      a6ec
ZY      a6f2
ZZ      a6f8
ZAA     a6fe
ZAB     a704
ZBA     a70a
ZBB     a715
ZBC     a71f
ZBF     a72a
ZBH     a734
ZBI     a73e
ZBJ     a748
ZBK     a752
ZBL     a75c
ZBM     a767
ZBN     a772
ZBO     a77d
ZPB     a788
ZBQ     a793
ZBR     a79e
ZBS     a7a9
ZBT     a7b4
ZBU     a7bd
ZBV     a7c5
ZBW     a7d0
ZBX     a7d9
ZBY     a7e6
ZBZ     a7f1
ZCA     a7fb
ZCB     a807
ZCC     a80e
ZCD     a818
ZEA     a822
ZEB     a828
ZEC     a82e
ZEF     a834
ZEH     a83a
ZEI     a840
ZEJ     a846
ZEK     a84c
ZEL     a852
ZEM     a858
ZEN     a85e
ZEO     a864
ZEP     a86a
ZEQ     a870
ZER     a876
ZES     a87c
ZET     a882
ZEU     a888
ZEV     a88e
ZEX     a894
ZEY     a89a
ZEZ     a8a0
ZFA     a8a6
ZFC     a8ac
ZFD     a8b2
ZFE     a8b8
ZFF     a8be
ZFG     a8c4
ZFH     a8ca
ZFI     a8d0
ZFJ     a8d6
ZFK     a8dc
ZFL     a8e2
ZFM     a8e8
ZFN     a8ee
ZFQ     a8f4
ZFR     a8fa
ZFS     a900
ZFT     a906
ZFU     a90c
ZFV     a912
ZFW     a918
ZFX     a91e
ZFY     a924
ZFZ     a92a
ZGA     a930
ZGB     a936
ZGD     a93c
ZGE     a942
ZGF     a948
ZGG     a94e

; ******************************
; The second LISP image file
; ******************************
        a94e+8
        ab90  ; N.B. ZMQ IS USED
; ******************************
; Routines new to version 2
; ******************************
        ac90+8

RELTAB  B800
ROMTOP  C000
HILISP  D700
HILISP+1  D701
HILISP+2  D702
HIWARM  DO78
"""

# word(0x823e)

def output_multiline_comment(addr):
    global current_multiline_comment
    if current_multiline_comment != "":
        blank(addr)
        comment(addr, current_multiline_comment, indent=1)
        current_multiline_comment = ""

current_multiline_comment = ""
old_addr = -1
addr = 0
for line in labels.splitlines():
    orig_line = line
    line = line.rstrip().split('#')[0].strip()
    parts = line.split(';')
    if len(parts) == 1:
        parts.append("")
    line = parts[0]
    line_comment = parts[1]
    if len(line_comment) > 0 and line_comment[0] == ' ':
        line_comment = line_comment[1:]

    m = re.match(r"(.*) *([0-9a-fA-F]{4}.*)", line)
    if m:
        name = m.group(1).strip()
        addr = eval("0x" + m.group(2))
        if old_addr > addr:
            print("Label {0} out of order at addr {1}. See line '{2}'".format(name, hex(addr), orig_line))
        else:
            old_addr = addr
        output_multiline_comment(addr)
        if name != "":
            label(addr, name)
        if line_comment != "":
            comment(addr, line_comment, inline=True)
            line_comment = ""
    elif len(line.strip()) > 1:
        output_multiline_comment(addr+1)
        annotate(addr+1, line, priority=0)

    if len(current_multiline_comment) > 0:
        if current_multiline_comment[-1] != "\n":
            current_multiline_comment += "\n"
    current_multiline_comment += line_comment

label(0x0000, "GCNO")
label(0x0001, "GCNO+1")
label(0x0002, "GARX")
label(0x0003, "GARRY")
label(0x0004, "GCA")
label(0x0005, "GCA+1")
label(0x0006, "GABBY")
label(0x0007, "SA")
label(0x0008, "SA+1")

# unused
#label(0x0009, "TOPDIP")
#label(0x0009, "SD")
#label(0x000A, "TOPDIP+1")
#label(0x000A, "SD+1")

label(0x000B, "DISPM")
label(0x000C, "DISPM+1")
label(0x000D, "ERRCNT")
label(0x000E, "ERRCNT+1")
label(0x000F, "TOPBIN")
label(0x0011, "ERRNO")
label(0x0012, "LINEPP")
label(0x0013, "HANDLE")
label(0x0014, "NBUFF")
label(0x0019, "NIND")
label(0x001a, "LEVEL")
label(0x001b, "OLDEXT")
label(0x001c, "OLDEXT+1")
label(0x001d, "END")
label(0x001e, "AA")
label(0x001f, "AA+1")
label(0x0020, "AB")
label(0x0021, "AB+1")
label(0x0022, "YSAV")
label(0x0023, "XREP")
label(0x0024, "XREP+1")
label(0x0025, "LINENO")
label(0x002e, "TVS-2")
label(0x002f, "ARG-1")

label(0x0030, "ARG")
label(0x0030, "TVS")

label(0x0031, "ARG+1")
label(0x0031, "TVS+1")

label(0x0032, "BINDER")
label(0x0033, "TVSEXT")
label(0x0034, "WSA")
label(0x0035, "WSA+1")
label(0x0036, "WSB")
label(0x0037, "WSB+1")
label(0x0038, "WSC")
label(0x0039, "WSC+1")
label(0x003a, "ARGA")
label(0x003b, "ARGA+1")
label(0x003c, "ARGB")
label(0x003d, "ARGB+1")
label(0x003e, "ARGC")
label(0x003f, "ARGC+1")
label(0x0040, "ARGD")
label(0x0041, "ARGD+1")
label(0x0042, "ARGE")
label(0x0043, "ARGE+1")

label(0x0072, "ACL")
label(0x0073, "ACL+1")
label(0x0074, "XTNDL")
label(0x0075, "XTNDL+1")
label(0x0076, "AUXL")
label(0x0077, "AUXL+1")
label(0x0078, "SIGN")
label(0x0079, "ARETOP")

label(0x007A, "POINT")
label(0x007A, "RELBS")
label(0x007A, "ROMBS")

label(0x007B, "POINT+1")
label(0x007B, "RELBS+1")
label(0x007B, "ROMBS+1")

label(0x007C, "CELL")
label(0x007C, "RELOC")
label(0x007C, "RAMBS")

label(0x007D, "CELL+1")
label(0x007D, "RELOC+1")
label(0x007D, "RAMBS+1")

label(0x007E, "SP")
label(0x007F, "SP+1")
label(0x0082, "SIZE")
label(0x0083, "WSD")
label(0x0084, "WSD+1")
label(0x0085, "RETADD")
label(0x0086, "RETADD+1")
label(0x0087, "AD")
label(0x0088, "AD+1")
label(0x0089, "XPR")
label(0x008B, "DEPTH")
label(0x008C, "LSBUFF")
label(0x008D, "POPPY")
label(0x008E, "TERMCH")
label(0x008F, "ACIN")
label(0x0090, "ARGINF")
label(0x0097, "OLDLEV")
label(0x00F2, "CLISTR")
label(0x00FD, "BRKAD")
label(0x0400, "FIRST")
label(0x0401, "TUBE")
label(0x0402, "ACL40")
label(0x0403, "ACL40+1")
label(0x0407, "REM40")
label(0x040C, "AUX40")
label(0x0411, "TEMP40")
label(0x0416, "IODCB")
label(0x0417, "IODCB+1")
label(0x0418, "IODCB+2")
label(0x0419, "IODCB+3")
label(0x041a, "IODCB+4")
label(0x041b, "PWORD")
label(0x041c, "PWORD+1")
label(0x041d, "PWORD+2")
label(0x041e, "PWORD+3")
label(0x041f, "PWORD+4")
label(0x0420, "GCTIME")
label(0x0425, "TIMEW")
label(0x042a, "MODEF")
label(0x042b, "VECBOT")
label(0x042c, "IMBOT")
label(0x042d, "AREVAL")
label(0x042e, "AREVAL+1")
label(0x042f, "ESCHF")
label(0x0430, "LSCHAR")
label(0x0431, "STATYP")
label(0x0432, "MEMINV")
label(0x0433, "RELOFF")
label(0x0434, "GENCNT")
label(0x0438, "OSINFO")
label(0x0439, "OSINFO+1")
label(0x043a, "OSINFO+2")
label(0x043b, "OSINFO+3")
label(0x043c, "OSINFO+4")
label(0x043d, "OSINFO+5")
label(0x043e, "OSINFO+6")
label(0x0442, "OSINFO+10")
label(0x0443, "OSINFO+11")
label(0x0444, "OSINFO+12")
label(0x0445, "OSINFO+13")
label(0x0446, "OSINFO+14")
label(0x0447, "OSINFO+15")
label(0x0448, "OSINFO+16")
label(0x0449, "OSINFO+17")
label(0x0450, "DL")
label(0x0520, "DH")
label(0x05f6, "OSWBUF-10")
label(0x05f7, "OSWBUF-9")
label(0x05fa, "OSWBUF-6")
label(0x05fb, "OSWBUF-5")
label(0x0600, "OSWBUF")
label(0x0600, "NAMBUF")
label(0x0600, "IMBUF")
label(0x0601, "IMBUF+1")
label(0x0602, "IMBUF+2")
label(0x06fa, "DOSBUF-6")
label(0x0700, "DOSBUF")

comment(0x8000, "Standard language ROM header", inline=False)
entry(0x8000)
entry(0x8003)
comment(0x8003, "Service entry", inline=True)
byte(0x8006,1)
byte(0x8008,1)
comment(0x8006, "Language, service & tube", inline=True)
expr(0x8007, "CPYOFF-ROMHDR")
comment(0x8008, "ROM version", inline=True)
for i in [0x8198, 0x81a5, 0x81b1, 0x81b4, 0x81b7, 0x81CB, 0x81d2, 0x81e4,
          0x81f0, 0x81f5, 0x8203, 0x820a, 0x8226]:
    stringhi(i, include_terminator_fn=lambda x : True)

word(0x823e)

entry(0x82ef)
entry(0x851e)
entry(0x88dc)
entry(0x88ee)
entry(0x89d3)
entry(0x89e8)
entry(0x8aa6)
entry(0x8abc)
entry(0x8ad7)
entry(0x8aec)
entry(0x8b04)
entry(0x8b26)
entry(0x8b2a)
entry(0x8b6f)
entry(0x8ca9)
entry(0x8cd0)
entry(0x8cee)
entry(0x8d2f)
entry(0x8d4d)
entry(0x8d65)
entry(0x8dc4)
entry(0x8dd8)
entry(0x8de9)
entry(0x8dfa)
entry(0x8e1e)
entry(0x8e34)
entry(0x8e3a)
entry(0x8e6c)
entry(0x8ea3)
entry(0x8ec0)
entry(0x8ecd)
entry(0x8eeb)
entry(0x8f0a)
entry(0x8f1f)
entry(0x8f5c)
entry(0x8f77)
entry(0x8fb1)
entry(0x8fba)
entry(0x8fc9)
entry(0x8fd7)
entry(0x8fe7)
entry(0x8ff9)
entry(0x9000)
entry(0x9098)
entry(0x9174)
entry(0x917a)
entry(0x91c1)
entry(0x91d9)
entry(0x91f2)
entry(0x9229)
entry(0x923a)
entry(0x925d)
entry(0x92b5)
entry(0x92e0)
entry(0x92ef)
entry(0x9327)
entry(0x9355)
entry(0x93aa)
entry(0x93d6)
entry(0x93ec)
entry(0x944a)
entry(0x94b3)
entry(0x94bc)
entry(0x9536)
entry(0x9578)
entry(0x9592)
entry(0x9595)
entry(0x95a5)
entry(0x9605)
entry(0x9622)
entry(0x962f)
entry(0x96aa)
entry(0x96fe)
entry(0x9752)
entry(0x9760)
entry(0x9770)
entry(0x97d2)
entry(0x985e)
entry(0x988b)
entry(0x98ee)
entry(0x98f4)
entry(0x9911)
entry(0x9966)
entry(0x999f)
entry(0x99c2)
entry(0x9a0a)
entry(0x9a46)
entry(0x9a5e)
entry(0x9a8e)
entry(0x9e87)
entry(0x9f95)
entry(0x9fc4)

for addr in range(0xa400, 0xa538, 3):
    entry(addr)

byte(0xa600,2)

constant(0, "CHARF")
constant(4, "NUMF")
constant(8, "SUBRF")
constant(0x0c, "FSUBRF")
constant(0x80, "LISTF")

types = {
    0:  "CHARF",
    4:  "NUMF",
    8:  "SUBRF",
    0x0c: "FSUBRF",
    0x80: "LISTF"
}

for addr in [0xa602, 0xa611, 0xa618, 0xa624, 0xa62d, 0xa638, 0xa642, 0xa64d,
             0xa657, 0xa661, 0xa66a, 0xa672, 0xa67c, 0xa685, 0xa68f, 0xa699,
             0xa6a2, 0xa6ac, 0xa6b6, 0xa6bc, 0xa6c2, 0xa6c8, 0xa6ce, 0xa6d4,
             0xa6da, 0xa6e0, 0xa6e6, 0xa6ec, 0xa6f2, 0xa6f8, 0xa6fe, 0xa704,
             0xa70a, 0xa715, 0xa71f, 0xa72a, 0xa734, 0xa73e, 0xa748, 0xa752,
             0xa75c, 0xa767, 0xa772, 0xa77d, 0xa788, 0xa793, 0xa79e, 0xa7a9,
             0xa7b4, 0xa7bd, 0xa7c5, 0xa7d0, 0xa7d9, 0xa7e6, 0xa7f1, 0xa7fb,
             0xa807, 0xa80e, 0xa818, 0xa822, 0xa828, 0xa82e, 0xa834, 0xa83a,
             0xa840, 0xa846, 0xa84c, 0xa852, 0xa858, 0xa85e, 0xa864, 0xa86a,
             0xa870, 0xa876, 0xa87c, 0xa882, 0xa888, 0xa88e, 0xa894, 0xa89a,
             0xa8a0, 0xa8a6, 0xa8ac, 0xa8b2, 0xa8b8, 0xa8be, 0xa8c4, 0xa8ca,
             0xa8d0, 0xa8d6, 0xa8dc, 0xa8e2, 0xa8e8, 0xa8ee, 0xa8f4, 0xa8fa,
             0xa900, 0xa906, 0xa90c, 0xa912, 0xa918, 0xa91e, 0xa924, 0xa92a,
             0xa930, 0xa936, 0xa93c, 0xa942, 0xa948, 0xa94e, 0xa958, 0xa968,
             0xa973, 0xa97e, 0xa989, 0xa997, 0xa9a6, 0xa9b1, 0xa9bb, 0xa9c5,
             0xa9d2, 0xa9de, 0xa9ea, 0xa9f5, 0xaa01, 0xaa09, 0xaa15, 0xaa22,
             0xaa2b, 0xaa34, 0xaa41, 0xaa4f, 0xaa5a, 0xaa61, 0xaa68, 0xaa73,
             0xaa7e, 0xaa89, 0xaa90, 0xaa9a, 0xaaa5, 0xaaaf, 0xaabb, 0xaac2,
             0xaac9, 0xaad0, 0xaad7, 0xaae2, 0xaaee, 0xaafe, 0xab0c, 0xab16,
             0xab20, 0xab2a, 0xab36, 0xab41, 0xab4b, 0xab54, 0xab63, 0xab70,
             0xab7d, 0xab8a, 0xab97, 0xaba5, 0xabb0, 0xabba, 0xabc6, 0xabd1,
             0xabda, 0xabe3, 0xabef, 0xabfa, 0xac00, 0xac06, 0xac0c, 0xac12,
             0xac18, 0xac1e, 0xac24, 0xac2a, 0xac30, 0xac36, 0xac3c, 0xac42,
             0xac48, 0xac4e, 0xac54, 0xac5a, 0xac60, 0xac66, 0xac6c, 0xac72,
             0xac78, 0xac7e, 0xac84, 0xac8a, 0xac90,
             # USR
             0xac9a, 0xaca3, 0xacae, 0xacbc, 0xacc8, 0xacd2, 0xacdd, 0xace8,
             0xacf3, 0xacfe, 0xad08, 0xad12, 0xad1b, 0xad26, 0xad32, 0xad38,
             0xad3e, 0xad44, 0xad4a, 0xad50, 0xad56, 0xad5c, 0xad62, 0xad68,
             0xad6e, 0xad74, 0xad7a, 0xad80, 0xad86,
             0xad8c, 0xad9d, 0xadac, 0xadbb, 0xadc7, 0xae1c, 0xae2b, 0xae3a,
             0xaf87, 0xaf91, 0xaf98, 0xafea, 0xaff3,
             0xb41b, 0xb425, 0xb4df, 0xb4ea

]:
    blank(addr)
    byte(addr, 2)
    v = get_u8_binary(addr)
    if v in types:
        expr(addr, types[v])
    word(addr+2, 2, 1)
    string(addr+6)
byte(0x8240, 1)
byte(0x8241, 1)
byte(0x8242, 1)
expr(0x8069, "<VECTAB")
expr(0x806f, ">VECTAB")

constant(0x12, "IMALEN")
expr(0x8078, "IMALEN")
expr(0x8090, "'0'")
constant(42, "WARMST")
expr(0x809d, "WARMST")
expr(0x80a5, "<LISPST")
expr(0x80a9, ">LISPST")
expr(0x80ad, "<HILISP")
expr(0x80b1, ">HILISP")
expr(0x80b5, "(>(LISPEN-LISVAL-1))+1")
expr(0x80ba, "<RELTAB")
expr(0x80be, ">RELTAB")
expr(0x80c2, ">(HILISP-LISVAL)")
expr(0x80c7, "<VECTAB+2")
expr(0x80d5, ">(HILISP-LISVAL)")

expr(0x80f0, "<HIWARM")
expr(0x80f5, ">HIWARM")
constant(4, "service_unrecognised_star_command")
constant(9, "service_star_help_command")
expr(0x8135, "service_unrecognised_star_command")
expr(0x8139, "service_star_help_command")
expr(0x8146, "HLPOFF")
expr(0x815b, "'L'")
expr(0x8162, "'I'")
expr(0x8169, "'S'")
expr(0x8170, "'P'")
constant(42, "WARMST")
constant(0, "COLDST")
expr(0x8187, "COLDST")
expr(0x827f, "WARMST")
expr(0x828b, "WARMST")
expr(0x829b, "WRMOFF")
expr(0x82a5, "'C'")
expr(0x82a9, "'c'")
expr(0x82ad, "'W'")
expr(0x82b5, "'C'")
expr(0x82da, "EVOFF")
expr(0x82e5, "VALOFF")
expr(0x830e, "NUMF")
expr(0x8332, "<CTRUE")
expr(0x8440, "NUMF")
expr(0x8444, "CHARF")
expr(0x8448, "FSUBRF")
expr(0x844e, "SUBRF")
expr(0x849a, "<ZA")
expr(0x84b6, "<ERROR")
expr(0x84bb, ">ERROR")
label(0xff, "KBD")
expr(0x84e8, "<KBD")
expr(0x84ed, ">KBD")
expr(0x85bc, "<LAMBDA")
expr(0x85da, "FSUBRF")
expr(0x85de, "SUBRF")
expr(0x8792, "'['")
expr(0x87e2, "' '")
char(0x87e6)
expr(0x87ea, "<QUOTE")
expr(0x8827, "'('")
expr(0x882d, "'!'")
expr(0x8850, "'!'")
expr(0x887e, "'.'")
expr(0x88c2, "'.'")
expr(0x8915, "' '")
expr(0x891d, "')'")
expr(0x895a, "'-'")
expr(0x89b5, "<ACL")
expr(0x8a3e, "<NIL")
expr(0x8ade, ">WRITGO")
expr(0x8ae6, "<WRITGO+2")
expr(0x8b18, ">PRINGO")
expr(0x8b20, "<PRINGO+2")
expr(0x8b62, "NUMF")
expr(0x8b90, "NILOFF")
expr(0x8b9b, "'('")
expr(0x8bad, "' '")
expr(0x8bd2, "')'")
expr(0x8bf0, "NUMF")
expr(0x8bf4, "SUBRF")
expr(0x8bf8, "FSUBRF")
expr(0x8bfc, "'F'")
expr(0x8c01, "SUBOFF")
expr(0x8c30, "'!'")
expr(0x8c4c, "'-'")
expr(0x8c51, "ACL")
expr(0x8cb2, "ACL")
expr(0x8cb9, "ARGINF")
expr(0x8ece, "SUBRF")
expr(0x8ed2, "FSUBRF")
expr(0x8ed6, "LISTF")
expr(0x8eda, "NUMF")
expr(0x8efa, "NUMF")
expr(0x8f13, "NUMF")
constant(0, "AREEXT")
expr(0x8f2d, "AREEXT")
expr(0x8f69, "AREEXT")
expr(0x8fcd, ">(BACALL+1)")
expr(0x8fd0, "<(BACALL+1)")
expr(0x9042, "<ZA")
expr(0x9056, "<NAMBUF")
expr(0x905b, ">NAMBUF")
expr(0x90f6, "CHARF")
expr(0x90fa, "SUBRF")
expr(0x90fe, "FSUBRF")
expr(0x9102, "NUMF")
expr(0x915e, "AREEXT")
expr(0x917b, "ACL")
expr(0x917f, "XTNDL")
expr(0x91ad, "ACL")
expr(0x9298, "ACL")
expr(0x9488, "NUMF")
expr(0x94c9, "SUBRF")
expr(0x94e1, "<LAMBDA")
expr(0x9710, "<NIL")
expr(0x98b6, "TVS+10")
expr(0x98bb, "TVS+10")
expr(0x98ea, "<TIMEW")
expr(0x98ec, ">TIMEW")
expr(0x98f5, "<GCTIME")
expr(0x98f7, ">GCTIME")
expr(0x9a0b, "'G'")
expr(0x9a1c, "'0'")
expr(0x9a32, "<ZA")
constant(2, "WSBOT")
expr(0x9abf, "WSBOT")
expr(0x9b08, "SUBRF")
expr(0x9b6e, "GCOFF")
expr(0x9c7d, "SUBRF")
expr(0x9cdd, "BINDER")
expr(0x9ced, "TVS-1")
expr(0x9d06, "SUBRF")
expr(0x9d0a, "NUMF")
expr(0x9da6, "'^'")
expr(0x9dae, "COLOFF")
expr(0x9dc5, "FROFF")
expr(0x9e2f, "SUBRF")
expr(0x9ecf, "ERROFF")
expr(0x9f1b, ">(ELFIN-1)")
expr(0x9f21, "<(ELFIN-1)")
expr(0x9f3d, "<DWARF")
expr(0x9f42, ">DWARF")
expr(0x9f6b, "'='")
expr(0x9f70, "' '")
expr(0x9fbc, "ARGOFF")
expr(0xa02a, "AUXL")
expr(0xa02f, "ACL")
label(0xb4f7, "unused3")
label(0xbb5e, "unused4")

# disambiguate
expr(0x8434, "TVS")
expr(0x8439, "TVS+1")
expr(0x84d9, "TVS")
expr(0x85ef, "TVS")
expr(0x85f4, "TVS")
expr(0x8649, "TVS")
expr(0x864e, "TVS+1")
expr(0x86c5, "TVS")
expr(0x86ca, "TVS")
expr(0x86f1, "TVS")
expr(0x86f6, "TVS+1")
expr(0x8b3c, "TVS")
expr(0x8b41, "TVS")
expr(0x8e8b, "TVS")
expr(0x8e91, "TVS")
expr(0x8ea9, "TVS")
expr(0x8ead, "TVS+1")
expr(0x923b, "TVS")
expr(0x923f, "TVS+1")
expr(0x9272, "TVS")
expr(0x9276, "TVS+1")
expr(0x948e, "TVS+1")
expr(0x9492, "TVS")
expr(0x954f, "TVS")
expr(0x9555, "TVS")
expr(0x957e, "TVS")
expr(0x9583, "TVS")
expr(0x964e, "TVS")
expr(0x9654, "TVS-1")
expr(0x9661, "TVS-1")
expr(0x9666, "TVS")
expr(0x968a, "TVS")
expr(0x968e, "TVS-1")
expr(0x969e, "TVS")
expr(0x96a4, "TVS")
expr(0x9866, "TVS")
expr(0x986a, "TVS+1")
expr(0x9893, "TVS")
expr(0x9897, "TVS+1")
expr(0x9a72, "TVS")
expr(0x9a76, "TVS+1")
expr(0x9aa2, "TVS")
expr(0x9aa6, "TVS+1")
expr(0x9b8a, "TVS-1")

expr(0x806b, "ROMBS")
expr(0x806d, "RAMBS")
expr(0x8071, "ROMBS+1")
expr(0x8076, "RAMBS+1")
expr(0x80a7, "ROMBS")
expr(0x80ab, "ROMBS+1")
expr(0x80bc, "RELBS")
expr(0x80c0, "RELBS+1")
expr(0x80c9, "RELBS")
expr(0x80ce, "RELBS+1")
expr(0x80d2, "RELBS")
expr(0x80d7, "RELBS")
expr(0x80d9, "RELBS")
expr(0x80de, "RELBS")
expr(0x80e0, "RELBS+1")
expr(0x80e4, "RELBS+1")
expr(0x8103, "ROMBS")
expr(0x8105, "RAMBS")
expr(0x810a, "RAMBS+1")
expr(0x810c, "ROMBS+1")
expr(0x8119, "RELBS")
expr(0x811b, "RELOC")
expr(0x811e, "RELBS")
expr(0x8122, "RELOC+1")
expr(0x8124, "RELOC")
expr(0x812a, "RELOC")
expr(0x812f, "RELBS+1")
expr(0x8f6b, "RELBS")
expr(0x8f70, "RELBS+1")
expr(0x90d2, "RELBS")
expr(0x90dd, "RELBS")
expr(0x90e3, "RELBS")
expr(0x90ec, "RELBS")
expr(0x90f4, "RELBS")
expr(0x911d, "RELBS")
expr(0x9130, "RELBS")
expr(0x9138, "RELBS")
expr(0x9142, "RELBS")
expr(0x9142, "RELBS")
expr(0x9144, "RELBS")
expr(0x9148, "RELBS+1")
expr(0x914a, "RELBS+1")
expr(0x9153, "RELBS")
expr(0x9160, "RELBS")
expr(0x9165, "RELBS+1")
expr(0x916c, "RELBS")
expr(0x9172, "RELBS")
expr(0x80af, "RAMBS")
expr(0x80b3, "RAMBS+1")

#expr(0x, "")
#expr(0x, "")
#expr(0x, "")
#expr(0x, "")
#expr(0x, "")
#expr(0x, "")
#expr(0x, "")
#expr(0x, "")
#expr(0x, "")
#expr(0x, "")
#expr(0x, "")
#expr(0x, "")
#expr(0x, "")
#expr(0x, "")
#expr(0x, "")
#expr(0x, "")
#expr(0x, "")
#expr(0x, "")
#expr(0x, "")

# Calculated expressions put at the end of the assembly so they resolve on the first pass
# which makes the asserts following them work.
# end_addr = 0xa538
# annotate(end_addr, "HIWARM = WRMCHK + HILISP - LISVAL")
# annotate(end_addr, "EVOFF  = TEXT-TEXT")
# annotate(end_addr, "VALOFF = VALTXT-TEXT")
# annotate(end_addr, "NILOFF = NILTXT-TEXT")
# annotate(end_addr, "DOTOFF = DOTTXT-TEXT")
# annotate(end_addr, "INSOFF = INSTXT-TEXT")
# annotate(end_addr, "GCOFF  = GCTXT-TEXT")
# annotate(end_addr, "COLOFF = COLTXT-TEXT")
# annotate(end_addr, "FROFF  = FRTXT-TEXT")
# annotate(end_addr, "SUBOFF = SUBTXT-TEXT")
# annotate(end_addr, "ERROFF = ERRTXT-TEXT")
# annotate(end_addr, "ARGOFF = ARGTXT-TEXT")
# annotate(end_addr, "WRMOFF = WRMTXT-TEXT")
# annotate(end_addr, "HLPOFF = HLPTXT-TEXT")

blank(0xb800)
comment(0xb800, "relocation table (entries point to high bytes of addresses)")
annotate(0xb800, "MOVE_OFFSET = HILISP-LISVAL")
for a in range(0xb800, 0xbb5e, 2):
    word(a)
    v = get_u16_binary(a) - 0x5700
    expr(a, "MOVE_OFFSET + ${0}".format(hex(v)[2:]))

go()
